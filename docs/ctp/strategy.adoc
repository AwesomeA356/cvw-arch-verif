
== General Test Plan Strategy

Coverpoints are written with one file that covers both RV32 and RV64, to reduce the duplication and risk of becoming out of sync.  When a coverage file contains coverpoints that apply only to one XLEN or the other (e.g. 32 or 64-bit edge values), they are separated by ``ifdef XLEN32` or `XLEN64` directives.

Privileged tests are mostly written by hand and share a single .S file that can be compiled for either RV32 or RV64, again with `ifdef` directives to separate the two.  Unprivileged tests are generated from a template using a Python script, and are divided into RV32 and RV64 directories because the random values differ with XLEN.

=== Configuration

* UDB
* Profiles, options, configuration parameters
* Other parameters: PMP entries, PMP granularity

=== Unspecified and Reserved Behaviors

Some RISC-V behaviors are UNSPECIFIED, which means an implementation can do anything. These behaviors are not tested because there is no wrong answer. <<t-behavior-normative-statements>> summarizes the normative statements regarding reserved behaviors.

Unimplemented opcodes (except in the custom space) and instructions accessing non-existent CSRs are reserved.  The behavior of reserved instructions is UNSPECIFIED, so they should not be tested by most testplans.  However, when the Ssstrict extension is enabled, reserved instructions raise an illegal instruction exception that results in a contained trap to the supervisor-mode trap handler.  This is tested by the Ssstrict test plan.

[[t-behavior-normative-statements]]
.I Normative Statements Regarding Behaviors
[cols="1, 4" options=header]
|===
|Spec Section|Normative Statement
|Unpriv 1.7|The term UNSPECIFIED refers to a behavior or value that is intentionally unconstrained.
|Unpriv 2.2|For this purpose, we divide each RISC-V
instruction-set encoding space (and related encoding spaces such as the CSRs) into three disjoint
categories: standard, reserved, and custom. ... Reserved encodings are currently not defined but are saved for future standard extensions; once thus used, they become standard encodings. ... The behavior upon decoding a reserved instruction is UNSPECIFIED.
|Privileged 2.1|Instructions that access a non-existent CSR are reserved.
|https://github.com/riscv/riscv-profiles/blob/main/src/rva23-profile.adoc#rva23s64-profile[rva23-profile]|Ssstrict No non-conforming extensions are present. Attempts to execute unimplemented opcodes or access unimplemented CSRs in the standard or reserved encoding spaces raises an illegal instruction exception that results in a contained trap to the supervisor-mode trap handler.
|===

=== CSR Bitfields

CSR fields can be Write Preserves, Read Ignores (WPRI), Write Legal, Read Legal (WLRL), or Write Any, Read Legal (WARL). Examples of WPRI fields include undefined fields of `xstatus`, `xenvcfg`, `mseccfg`, and `xstateen*` that could have unintended side effects if they are subsequently defined and unwittingly set to nonzero values. Examples of WLRL fields include `xcause.ExceptionCode` and `hstatus.VGEIN`.  Other CSR fields are generally WARL.

WPRI fields are not tested. WLRL fields are tested with all legal values but no illegal values.   WARL fields are tested by trying all possible values of the field.  CSR tests (<<Zicsr>>) generally involve setting all bits to 1, setting all to 0, and writing walking 1s.   Therefore, they inherently exercise all possible values of 1 and 2-bit WARL fields.  Longer fields can be tested exhaustively if the number of possibilities is small (such as `satp.MODE`), or just with walking 1s if the number of possibilities is too large (such as `misa.EXTENSIONS`).

<<t-bitfield-normative-statements>> summarizes the normative statements regarding CSR bitfields.

[[t-bitfield-normative-statements]]
.I Normative Statements Regarding Bitfields
[cols="1, 4" options=header]
|===
|Spec Section|Normative Statement
|Privileged 2.3|Some whole read/write fields are reserved for future use. Software should ignore the values read from
these fields, and should preserve the values held in these fields when writing values to other fields of
the same register. For forward compatibility, implementations that do not furnish these fields must
make them read-only zero. These fields are labeled *WPRI* in the register descriptions.
|Privileged 2.3|Some read/write CSR fields specify behavior for only a subset of possible bit encodings, with other bit encodings reserved. Software should not write anything other than legal values to such a field, and
should not assume a read will return a legal value unless the last write was of a legal value, or the
register has not been written since another operation (e.g., reset) set the register to a legal value.
These fields are labeled *WLRL* in the register descriptions.
|Privileged 2.3|Implementations are permitted but not required to raise an illegal-instruction exception if an
instruction attempts to write a non-supported value to a *WLRL* field. Implementations can return
arbitrary bit patterns on the read of a *WLRL* field when the last write was of an illegal value, but the
value returned should deterministically depend on the illegal written value and the value of the field
prior to the write.
|Privileged 2.3|Some read/write CSR fields are only defined for a subset of bit encodings, but allow any value to be
written while guaranteeing to return a legal value whenever read. Assuming that writing the CSR has no
other side effects, the range of supported values can be determined by attempting to write a desired
setting then reading to see if the value was retained. These fields are labeled *WARL* in the register
descriptions.
|Privileged 2.3|Implementations will not raise an exception on writes of unsupported values to a *WARL* field.
Implementations can return any legal value on the read of a *WARL* field when the last write was of an
illegal value, but the legal value returned should deterministically depend on the illegal written value
and the architectural state of the hart.
|===
