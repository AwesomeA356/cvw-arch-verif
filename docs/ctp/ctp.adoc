[[manual:ctp,RISC-V Certification Test Plan Draft Proposal]]
= RISC-V Certification Test Plan Draft Proposal
Draft of {docdatetime}

// These attributes have been copied over from riscv-isa-manual and are not yet all tested
//{approx} include::../docs-resources/global-config.adoc[]
:description: Certification Test Plan
:colophon:
:preface-title: Preamble
:appendix-caption: Appendix
:imagesdir: ../docs-resources/images
:title-logo-image: image:risc-v_logo.png["RISC-V International Logo",pdfwidth=3.25in,align=center]
ifdef::draft-watermark[]
:page-background-image: image:draft.png[opacity=20%]
endif::[]
//:title-page-background-image: none
//:back-cover-image: image:backpage.png[opacity=25%]
:back-cover-image: image:riscv-horizontal-color.svg[opacity=25%]
// Settings:
:experimental:
:reproducible:
:imagesoutdir: {docdir}/../build/images-out
:bibtex-file: src/resources/riscv-spec.bib
:bibtex-order: alphabetical
:bibtex-style: apa
:bibtex-format: asciidoc
:bibtex-throw: false
:icons: font
:lang: en
:example-caption: Example
:listing-caption: Listing
:sectnums:
:sectnumlevels: 5
:toc: left
:toclevels: 5
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: rouge
endif::[]
:table-caption: Table
:figure-caption: Figure
:xrefstyle: short
:chapter-refsig: Chapter
:section-refsig: Section
:appendix-refsig: Appendix
// Uncomment :data-uri: if your eBook reader is not capable of rendering
// embedded images. One known affected device is PocketBook InkPad 3.
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:le: &#8804;
:ge: &#8805;
:ne: &#8800;
:approx: &#8776;
:inf: &#8734;
:csrname: envcfg
:imagesdir: images

_Contributors to all versions of the spec in alphabetical order_

* Jordan Carlin
* James Kaden Cassidy
* David Harris
* Georgia Tai

_This document is released under a Creative Commons Attribution 4.0 International License._

This is a draft Certification Test Plan.  It reflects the coverpoints and tests
presently being developed in the https://github.com/openhwgroup/cvw-arch-verif/[cvw-arch-verif] repository soon to migrate to
https://github.com/riscv-non-isa/riscv-arch-test[riscv-arch-test] cvw branch.  It is intended for discussion as a possible format
of test plan for RISC-V Certification.

:toc:

== Introduction

This Certification Test Plan describes the coverpoints and tests to certify RISC-V profiles.  It summarizes the profiles intended to be supported and the test suites that need to run on each profile.  It also summarizes the contents of each test suite.

=== Coverpoints and Tests

Coverpoints are the key to certification.  They are the features of the RISC-V architecture that need to be tested in order to certify a profile.  Each coverpoint has a set of tests that exercise it, and each test has a set of coverpoints that it hits.

This test plan defines the coverpoints that must be hit for each profile, and outlines the tests that hit those coverpoints.  The tests are self-checking, and report pass/fail results.  The coverage report confirms that the tests hit all the coverpoints.

Coverpoints are written in SystemVerilog, and are designed to be used with the Extended https://github.com/riscv-verification/RVVI[RISC-V Verification Interface] (RVVI).  They are written to be independent of the DUT (Device Under Test), so that they can be used with any RISC-V implementation. footnote:[Extended RVVI adds signals for virtual memory verification, including physical and virtual instruction and data addresses, and I/D TLB entries.] Functional coverage is collected using SystemVerilog infrastructure adapted from https://github.com/riscv-verification/riscvISACOV[riscvISACOV] footnote:[Portions of riscvISACOV that depend on proprietary Synopsys code such as a disassembler have been replaced with open-source equivalents].

Coverpoints are organized into .svh SystemVerilog coverage files, each of which contain one or more covergroups, each of which contain one or more coverpoints.  Coverage files apply to a DUT with a particular set of extensions.  For example, the I_coverage.svh coverage file is used for any 32 or 64-bit DUT that supports the I extension. The ZicsrM_coverage.svh coverage file applies to a DUT that supports the Zicsr extension and machine mode.  The ZicsrS_coverage.svh coverage file applies to a DUT that supports the Zicsr extension and supervisor mode.

Tests are written in assembly language .S files.Tests are organized into directories for each extension, and into a privileged directory.  The coverpoints are hit by running all of the applicable tests in a directory.  For example, RV32I coverage involves running add.S, addi.S, sub.S, etc.  RV64I coverage also involves running addw.S, which is unique to RV64.

=== Glossary

The following terms are used in this test plan:

* Extensions: named and ratified RISC-V extensions, such as RV32I, M, Zbb, or Zicsr.

* Parameters: options describing the behavior of extensions.  Parameters may or may not have an official RISC-V name.  For example, the Sm machine mode extension defines
Physical Memory Protection, which has a named parameter G defining the granularity and an unnamed parameter indicating 0, 16, or 64 PMP regions.  The Sv* virtual memory extensions have additional Svade and Svadu extensions, which are parameters defining whether setting the Accessed and Dirty bits is done with a page fault exception or by the Hardware Page Table Walker. There is a completely unnamed parameter defining whether misaligned exceptions have higher or lower priority than access-fault exceptions.
Parameters will eventually all have formal names in UDB when they are all identified.

* Configuration: A set of extensions and parameters partially or fully describing the behavior of a RISC-V hart.  A full configuration is sufficient for a reference model to exactly match the behavior of a DUT except with regard to non-deterministic behaviors.

* Non-deterministic Behaviors: behaviors that are unpredictable despite a full configuration.  For example, a tail-agnostic vector instruction might copy vector elements from the source, or might provide elements that are all 1s.  Either behavior is correct, and the hart might change behaviors from one instruction to the next, so the DUT and reference model cannot be guaranteed to exactly match.  Self-checking tests must accept all legal outcomes for non-deterministic behaviors.

* Profile: A named collection of required and optional extensions, such as RVI20 or RVA23S64.  Profiles may be ratified by RISC-V or developed by the Certification Steering Committee to meet certification market needs, such as a simple microcontroller. A profile is a partial configuration.  The test plan must allow the DUT configuration to indicate which optional extensions and other parameters are used, and fully test all optional profile extensions provided by the DUT.


* UDB: https://github.com/riscv-software-src/riscv-unified-db[Unified Database], a standardized way to describe the configuration and generate config files for various tools from a single point of truth.

* Coverage files: a SystemVerilog .svh file containing all of the covergroups for an extension or combination of extensions, such as I_coverage.svh or ZfaD_coverage.svh.

* Covergroup: A SystemVerilog construct that contains one or more coverpoints.  Covergroups are used to collect functional coverage of a particular feature or set of features in the RISC-V architecture.  For example, the I_coverage.svh file contains a covergroup for each instruction in the I extension, such as add, addi, sub, etc.  The InterruptsM_coverage.svh contains a single InterruptsM_cg covergroup with all the coverpoints for machine-mode interrupts.

* Coverpoint: A SystemVerilog construct describing a set of conditions to test.  For example, the cp_rd coverpoint checks that all 32 destination registers x0-x31 are exercised by instructions that don't trap. Each coverpoint has one or more bins; for example, cp_rd has 32 bins for the different registers.

* Bin: One target value for a coverpoint.  Each bin may be covered or not by a test suite.

* Test files: A file containing one or more tests, typically written in assembly language.  For example, rv32/I/add.S contains all of the RV32 tests to exercise the add_cg covergroup in I_coverage.svh.

* Tests: A program, typically a sequence of assembly language instructions, that exercises at least one bin of a coverpoint.

* Test Suite: A collection of coverage and test files to test a particular extension, combination of extensions, or group of extensions.  For example, the RV32I test suite contains the I_coverage.svh coverage file and the rv32/I/add.S, addi.S, sub.S, and other tests files with tests that hit the coverpoints in that coverage file.  The RV64ZfaD test suite contains the ZfaD_coverage.svh coverage file and the rv64/ZfaD/fround.d.S, and other tests files with tests that hit the coverpoints in that coverage file.  The RVA23S64 test suite contains all of the required and selected optional test suites for the profile, incluidng RV64I, RV64ZfaD, ExceptionsS, etc.

[NOTE]
====
Beware that Test Suite is also used outside this document to mean a full set of tests for a given profile from a given provider.  For example, Synopsys, Breker, and riscv-arch-test all have test suites for the RVI20U32 profile.
====


== Certification Process

Certifying a RISC-V Device-Under-Test (DUT) involves the following steps:

* Selecting a profile for the DUT
* Providing a Unified Database (UDB) configuration for the DUT, such as optional extensions, peripheral addresses, and PMP granularity
* Generating self-checking tests based on the selected profile and UDB
* Running the tests and reporting pass/fail

Test developers also need to
* Generate a coverage report confirming that the tests hit all the coverpoints footnote:[Open question whether to generate coverage from a Sail log or the DUT.  DUT requires a suitable testbench with RVVI interface, but is more robust to check that the tests fully run.]

== Profiles & Test Suites

This test plan addresses Phase 0, Phase 1, and Phase 2 RISC-V certification objectives, including the following ratified and unratified profiles:

* https://drive.google.com/file/d/1Kg7Ner5ZlxFDclf92-9Tz88JvmZWt5Wb/view[RVI20 Profile] (Ratified)
** RV{32/64}IMAFDC_Zifencei_Zicntr_Zihpm with machine mode
* Microcontroller Profile (Not Ratified, but market demand)
** RV{32/64}IMZca_Zcb_Zifencei_Zicsr_Zicntr with machine mode, user mode, interrupts, PMP16 footnote:[Tentative; may need updating based on the MRD Market Requirements Document]
* https://drive.google.com/file/d/1Kg7Ner5ZlxFDclf92-9Tz88JvmZWt5Wb/view[RVA22S64 Profile] (Ratified)
** Application processor without vector, hypervisor, and other newer extensions
* https://github.com/riscv/riscv-profiles/blob/main/src/rvb23-profile.adoc#rvb23s64-profile[RVB23S64 Profile] (Ratified)
** RVA23 less vector and hypervisor
* https://github.com/riscv/riscv-profiles/blob/main/src/rva23-profile.adoc#rva23s64-profile[RVA23S64 Profile] (Ratified)

<<t-profiles>> summarizes the coverage files applicable to each profile. x indicates a mandatory extension, and o indicates an optional extension.  The certification test plan handles all mandatory and optional extensions.

Coverage files with multiple extensions in the name apply when all the extensions are supported; for example, ZfaZfhD is used in a system supporting Zfa, Zfh, and D extensions.

All privileged suites require at least version 1.12 of the privileged specification.  Features specific to version 1.13 are tested separately in the Sm1p13 and Ss1p13 suites.


[[t-profiles]]
.Profile Coverage Files
[options=header]
[cols="1, 4, 1, 1, 1, 1, 1" options=header]
[%AUTOWIDTH]
|===
|Coverage File|Description|RVI20|uController|RVA22S64|RVB23S64|RVA23S64
|XLEN||32/64|32|64|64|64
7+^|Unprivileged
|I|Integer|x|x|x|x|x
|M|Mult/Div|o|x|x|x|x
|Zmmul|Mult Only|||||
|Zaamo|Atomic Memory Ops|o|x|x|x|x
|Zalrsc|Load Reserved / Store Cond|o|x|x|x|x
|Zca|Compressed|o|x|x|x|x
|Zcb|Extra Compressed||x||x|x
|ZcbM|Compressed Multiply||x||x|x
|ZcbZba|Compressed Zero Extend||x||x|x
|ZcbZbb|Compressed Sign Extend||x||x|x
|Zcf|Compressed Float|o||||
|Zcd|Compressed Double|o||x|x|x
|F|Float|o||x|x|x
|D|Double|o||x|x|x
|Zfh|Half|||o|o|o
|ZfhD|Half-Double Converts|||o|o|o
|Zfhmin|Half Converts|||x|o|x
|ZfhminD|Half-Double Converts|||x|o|x
|ZfaF|Additional Float||||x|x
|ZfaD|Additional Double||||x|x
|ZfaZfh|Additional Half||||o|o
|ZfaZfhD|Additional Half-Double Converts||||o|o
|Zba|Address Generation||x|x|x|x
|Zbb|Basic Bit Manipulation||x|x|x|x
|Zbc|Carryless Multiplication|||||o
|Zbs|Single-Bit||x|x|x|x
|Zbkb|Bit Manip for Crypto||o||o|
|Zbkc|Carryless Multiply for Crypto||o||o|
|Zbkx|Permutations||o||o|
|Zknd|AES Decryption||o||o|
|Zkne|AES Encryption||o||o|
|Zknh|SHA2 Hashing||o||o|
|Zicsr|CSR Instructions|||x|x|x
|Zicond|Conditional Move||||x|x
|Zifencei|Instruction Fence|o|x|x|x|x
|Zihintpause|Pause Hint|||x|x|x
|Zihintntl|Nontemporal Locality Hint||||x|x
|ZihintntlZca|Compressed Nontemporal Locality Hint||||x|x
|Zicbom|Cache Block Flush/Inval|||x|x|x
|Zicboz|Cache Block Zero|||x|x|x
|Zicbop|Cache Block Prefetch|||x|x|x
|Zkr|Entropy CSR|||o|o|o
|Za64rs|Max 64B Reservation Sets|||x|x|x
|Zic64bZicboz|64B Cache Blocks|||x|x|x
7+^|Privileged
|ZicsrM|Machine CSRs||x|x|x|x
|ZicsrS|Supervisor CSRs|||x|x|x
|ZicsrU|User CSRs||x|x|x|x
|ZicsrF|Float CSRs|o||x|x|x
|ZicsrUF|User Float CSRs|||x|x|x
|ExceptionsM|Machine Exceptions||x|x|x|x
|ExceptionsS|Supervisor Exceptions|||x|x|x
|ExceptionsU|User Exceptions||x|x|x|x
|ExceptionsF|Float Exceptions||x|x|x|x
|ExceptionsZalrsc|LR/SC Exceptions||x|x|x|x
|ExceptionsZaamo|AMO Exceptions||x|x|x|x
|ExceptionsZc|Compressed Exceptions||x|x|x|x
|ExceptionsZicboS|Supervisor CBO Exceptions|||x|x|x
|ExceptionsZicboU|User CBO Exceptions|||x|x|x
|ExceptionsVM|Virt Mem Exceptions|||x|x|x
|ExceptionsVMZalrsc|Virt Mem LR/SC Exceptions|||x|x|x
|ExceptionsVMZaamo|Virt Mem AMO Exceptions|||x|x|x
|InterruptsM|Machine Interrupts||x|x|x|x
|InterruptsS|Supervisor Interrupts|||x|x|x
|InterruptsU|User Interrupts||x|x|x|x
|InterruptsSstc|Supervisor Timer Compare|||x|x|x
|ZicntrM|Machine Counters|o|x|x|x|x
|ZicntrS|Supervisor Counters|||x|x|x
|ZicntrU|User Counters||x|x|x|x
|ZihpmM|Machine Performance Monitors|o|x|x|x|x
|ZihpmS|Machine Performance Monitors|||x|x|x
|ZihpmU|Machine Performance Monitors||x|x|x|x
|PMPM|Machine PMP||x|x|x|x
|PMPS|Supervisor PMP|||x|x|x
|PMPU|User PMP||x|x|x|x
|PMPZca|Compressed PMP|||x|x|x
|PMPZicbo|CBO PMP|||x|x|x
|PMPZaamo|AMO PMP|||x|x|x
|PMPZalrsc|LR/SC PMP|||x|x|x
|Svbare|No Virtual Memory|||x|x|x
|Sv32|Sv32 Virtual Memory|||||
|RV32VM_PMP|VM + PMP|||||
|RV32CBO_VM|VM + CBO|||||
|RV32CBO_PMP|CBO + PMP|||||
|Sv39|Sv39/48/57 Virtual Memory|||x|x|x
|Sv48|Sv39/48/57 Virtual Memory|||o|o|o
|Sv57|Sv39/48/57 Virtual Memory|||o|o|o
|RV64VM_PMP|VM + PMP|||x|x|x
|RV64CBO_VM|VM + CBO|||x|x|x
|RV64CBO_PMP|CBO + PMP|||x|x|x
|Svinval|TLB Invalidation|||x|x|x
|Svade|Page Table A/D Exceptions|||x|x|x
|Svpbmt|Page-based Memory Types|||x|x|x
|Svnapot|Naturally Aligned Pages|||o|x|x
|Sscofpmf|Counter Filtering|||o|x|x
|Ssu64xl|64-bit UXL|||o|x|x
|Sscounterenw|Counter Enables Writable|||x|x|x
|Sstvecd|Direct Vector|||x|x|x
|Sstvala|stval Addresses|||x|x|x
|Zicclsm|Misaligned Loads / Stores|||x|x|x
|Smstateen|Machine State Enable|||||
|Ssstateen|Supervisor State Enable|||o||x
|EndianM|Machine Endian|||||
|EndianS|Supervisor Endian|||||
|EndianU|User Endian|||||
|EndianZaamo|AMO Endian|||||
|EndianZalrsc|LR/SC Endian|||||
7+^|Strict
|SsstrictM|Machine Strict (unratified)|||o|o|o
|SsstrictS|Superisor Strict|||o|o|o
7+^|Vector
|Vx8|Vector Integer 8-bit|||o|o|x
|Vx16|Vector Integer 16-bit|||o|o|x
|Vx32|Vector Integer 32-bit|||o|o|x
|Vx64|Vector Integer 64-bit|||o|o|x
|Vls8|Vector Load/Store 8-bit|||o|o|x
|Vls16|Vector Load/Store 16-bit|||o|o|x
|Vls32|Vector Load/Store 32-bit|||o|o|x
|Vls64|Vector Load/Store 64-bit|||o|o|x
|Vf16 (Zvfh)|Vector Float 16-bit||||o|o
|Vf32|Vector Float 32-bit|||o|o|x
|Vf64|Vector Float 64-bit|||o|o|x
|Zvbb8|Vector Bit Manip 8-bit||||o|x
|Zvbb16|Vector Bit Manip 16-bit||||o|x
|Zvbb32|Vector Bit Manip 32-bit||||o|x
|Zvbb64|Vector Bit Manip 64-bit||||o|x
|Zvkb8|Vector Crypto Bit Manip 8-bit||||o|o
|Zvkb16|Vector Crypto Bit Manip 16-bit||||o|o
|Zvkb32|Vector Crypto Bit Manip 32-bit||||o|o
|Zvkb64|Vector Crypto Bit Manip 64-bit||||o|o
|Zvbc64|Vector Carryless Mult||||o|o
|Zvg32|Vector GCM||||o|o
|Zvkned32|Vector Crypt||||o|o
|Zvknha32|Vector Hash 32-bit|||||
|Zvknhb64|Vecotr Hash 64-bit||||o|o
|Zvfbmin|Vector BF16 Convert||||o|o
|Zvfbwma|Vector BF16 MAC||||o|o
7+^|Vector Privileged
|ExceptionsV|Vector Exceptions|||o|o|x
|ZicsrV|Vector CSRs|||o|o|x
|ZicsrUV|User Vector CSRs|||o|o|x
|SsstrictV|Vector Strict|||o|o|o
7+^|Hypervisor
|H|Hypervisor Instructions|||o|o|x
|ZicsrH|Hypervisor CSRs|||o|o|x
|ZicsrHF|Hypervisor Float CSRs|||o|o|x
|ZicsrHV|Hypervisor Vector CSRs|||o|o|x
|ExceptionsH|Hypervisor Exceptions|||o|o|x
|ExceptionsHV|Hypervisor Vector Exceptions|||o|o|x
|InterruptsH|Hypervisor Interrupts|||o|o|x
|EndianH|Hypervisor Endian|||o|o|x
|ZicntrH|Hypervisor Counters|||o|o|x
|ZihpmH|Hypervisor Performance Monitors|||o|o|x
|PMPH|Hypervisor PMP|||o|o|x
|RV32VMH|Hypervisor Virtual Memory|||o|o|x
|RV32VMHCBO|Hypervisor Virtual Memory + CBO|||o|o|x
|RV64VMH|Hypervisor Virtual Memory|||o|o|x
|RV64VMHCBO|Hypervisor Virtual Memory + CBO|||o|o|x
|SsstrictH|Hypervisor Strict|||o|o|x
|Shcounterenw|Counter Enables|||o|o|x
|Shvsatpa|VM Modes Supported|||o|o|x
|Shgatpa|VM x4 Modes Supported|||o|o|x
|Shvstvecd|Direct Vectoring|||o|o|x
|Shvstvala|vstval Addresses|||o|o|x
|Shtvala|htval Addresses|||o|o|x
|Shlcofideleg|Counter Overflow Delegation|||o|o|x
|ZkrH|Hypervisor Entropy|||o|o|x
|SstcH|Hypervisor Supervisor Timer|||o|o|x
|SsstateenH|Hypervisor State Enable|||o|o|x
|SscrindH|Hypervisor Indirect CSR|||o|o|x
|SscfgH|Hypervisor Counter Delegation|||o|o|x
|SmctrH|Hypervisor Control Transfer Records|||o|o|x
|SvinvalH|Hypervisor TLB Inval|||o|o|o
|SvaduH|Hypervisor TLB Update|||o|o|o
|ZicfilpH|Hypervisor Landing Pad|||o|o|o
|ZicfissH|Hypervisor Shadow Stack|||o|o|o
|SsdbltrpH|Double Trap|||o|o|o
|SsnpmH|Pointer Masking|||o|o|o
|SmnpmH|Pointer Masking|||o|o|o
7+^|Miscellaneous RV{A/B}23 Extensions
|Sm1p13|Machine 1p13||||x|x
|Ss1p13|Supervisor 1p13||||x|x
|Ssnpm|Pointer Masking||||x|x
|Smnpm|Pointer Masking|||||
|Smmpm|Pointer Masking|||||
|Zacas|Atomic Compare-And-Swap||||o|o
|Zabha|Subword Atomics||||o|o
|Zicfilp|Landing Pads||||o|o
|Zicfiss|Shadow Stack||||o|o
|Zfbfmin|BF16 Convert||||o|o
|Zimop|Maybe-Ops||||x|x
|Zcmop|Compressed Maybe-Ops||||x|x
|Zawrs|Wait on Reservation Set||||x|x
|Svadu|Page Table Update||||o|o
|Sdtrig|Debug Triggers||||o|o
7+^|Other Recent Extensions
|Zfinx|Float in Int Regs|||||
|Zdinx|Double in Int Regs|||||
|Zhinx|Half in Int Regs|||||
|Zhinxmin|Half Cvt in Int Regs|||||
|Zcmp|Compressed Push/Pop|||||
|Zcmt|Compressed Table Jumps|||||
|Zilsd|Load/Store Double|||||
|Zclsd|Compressed Load/Store Double|||||
|Smcsrind|Machine Indirect CSRs|||||
|Sscsrind|Supervisor Indirect CSRs|||||
|Smepmp|Enhanced PMP|||||
|Smrnmi|Machine Resumable Interrupts|||||
|Ssrnmi|Supervisor Resumable Interrupts|||||
|Smcntrpmf|Cycle and Instret Mode Filtering|||||
|Smcdeleg|Counter Delegation|||||
|Ssccfg|Counter Delegation|||||
|Smdbltrp|Machine Double Trap|||||
|Ssdbltrp|Supervisor Double Trap|||||
|Smctr|Control Transfer Recores|||||
|Ssqosid|Quality-of-Service ID|||||
7+^|Embedded
|E|Embedded 16 Regs|||||
|EM|Multiply/Divide|||||
|EZmmul|Multiply|||||
|EZca|Compressed|||||
|EZcb|Additonal Compressed|||||
|EZcmp|Compressed Push/Pop|||||
|EZcmt|Compressed Table Jump|||||
|EZba|Address Generation|||||
|EZbb|Bit Manipulation|||||
|EZbs|Single-Bit|||||
7+^|Debug
|DM|Debug Module|||||
|DTM|Debug Transport Module|||||
|Sdext|Debug Mode|||||
7+^|Advanced Interrupt Architecture
|Smaia|Machine Advanced Interrupts|||||
|Ssaia|Supervisor Advanced Interrupts|||||
|===

=== Architecturally Untestable Extensions

<<t-untested>> lists certain extensions whose behavior is not readily visible at the architectural level of observed program behavior, such as constant-time instructions and PMAs.  These are outside the scope of certification.  PMA properties are implicitly tested by executing instructions that depend on the property, but not tested comprehensively across the entire memory map.

[[t-untested]]
.Extensions Lacking Architectural Visibility for Certification Testing
[options=header]
[cols="1, 4, 1, 1, 1, 1, 1" options=header]
[%AUTOWIDTH]
|===
|Coverage File|Description|RVI20|uController|RVA22S64|RVB23S64|RVA23S64
|Ziccif||||x|x|x
|Ziccrse||||x|x|x
|Ziccamoa||||x|x|x
|Ziccamoc|||||x|x
|Zama16b||||||x
|Zkt||||x|x|x
|Zvkt||||x|x|x
|Svvptc|||||x|x
|===

=== Conforming M-Mode Requirement

The privileged testplan relies on a machine mode conforming to Sm1p12 machine architecture or later.  The tests need to configure machine-mode CSRs that affect the behavior of lower privilege modes. This is done most easily by directly writing such registers using standard instructions in machine mode.  It is theoretically possible to write tests that only operate in S and U-mode, and use some sort of generalized SBI interface to request machine mode configurations even from non-conforming machine-mode implementations, but no such SBI interface exists at this time and the complexity seems to exceed the benefit.  Therefore, privileged tests rely on machine-mode, and also contain coverpoints and tests to check that privileged behaviors work correctly in machine mode.

== General Test Plan Strategy

Coverpoints are written with one file that covers both RV32 and RV64, to reduce the duplication and risk of becoming out of sync.  When a coverage file contains coverpoints that apply only to one XLEN or the other (e.g. 32 or 64-bit edge values), they are separated by ``ifdef XLEN32` or `XLEN64` directives.

Privileged tests are mostly written by hand and share a single .S file that can be compiled for either RV32 or RV64, again with `ifdef` directives to separate the two.  Unprivileged tests are generated from a template using a Python script, and are divided into RV32 and RV64 directories because the random values differ with XLEN.

=== Configuration

* UDB
* Profiles, options, configuration parameters
* Other parameters: PMP entries, PMP granularity

=== Unspecified and Reserved Behaviors

Some RISC-V behaviors are UNSPECIFIED, which means an implementation can do anything. These behaviors are not tested because there is no wrong answer. <<t-behavior-normative-statements>> summarizes the normative statements regarding reserved behaviors.

Unimplemented opcodes (except in the custom space) and instructions accessing non-existent CSRs are reserved.  The behavior of reserved instructions is UNSPECIFIED, so they should not be tested by most testplans.  However, when the Ssstrict extension is enabled, reserved instructions raise an illegal instruction exception that results in a contained trap to the supervisor-mode trap handler.  This is tested by the Ssstrict test plan.

[[t-behavior-normative-statements]]
.I Normative Statements Regarding Behaviors
[cols="1, 4" options=header]
|===
|Spec Section|Normative Statement
|Unpriv 1.7|The term UNSPECIFIED refers to a behavior or value that is intentionally unconstrained.
|Unpriv 2.2|For this purpose, we divide each RISC-V
instruction-set encoding space (and related encoding spaces such as the CSRs) into three disjoint
categories: standard, reserved, and custom. ... Reserved encodings are currently not defined but are saved for future standard extensions; once thus used, they become standard encodings. ... The behavior upon decoding a reserved instruction is UNSPECIFIED.
|Privileged 2.1|Instructions that access a non-existent CSR are reserved.
|https://github.com/riscv/riscv-profiles/blob/main/src/rva23-profile.adoc#rva23s64-profile[rva23-profile]|Ssstrict No non-conforming extensions are present. Attempts to execute unimplemented opcodes or access unimplemented CSRs in the standard or reserved encoding spaces raises an illegal instruction exception that results in a contained trap to the supervisor-mode trap handler.
|===

=== CSR Bitfields

CSR fields can be Write Preserves, Read Ignores (WPRI), Write Legal, Read Legal (WLRL), or Write Any, Read Legal (WARL). Examples of WPRI fields include undefined fields of `xstatus`, `xenvcfg`, `mseccfg`, and `xstateen*` that could have unintended side effects if they are subsequently defined and unwittingly set to nonzero values. Examples of WLRL fields include `xcause.ExceptionCode` and `hstatus.VGEIN`.  Other CSR fields are generally WARL.

WPRI fields are not tested. WLRL fields are tested with all legal values but no illegal values.   WARL fields are tested by trying all possible values of the field.  CSR tests (<<Zicsr>>) generally involve setting all bits to 1, setting all to 0, and writing walking 1s.   Therefore, they inherently exercise all possible values of 1 and 2-bit WARL fields.  Longer fields can be tested exhaustively if the number of possibilities is small (such as `satp.MODE`), or just with walking 1s if the number of possibilities is too large (such as `misa.EXTENSIONS`).

<<t-bitfield-normative-statements>> summarizes the normative statements regarding CSR bitfields.

[[t-bitfield-normative-statements]]
.I Normative Statements Regarding Bitfields
[cols="1, 4" options=header]
|===
|Spec Section|Normative Statement
|Privileged 2.3|Some whole read/write fields are reserved for future use. Software should ignore the values read from
these fields, and should preserve the values held in these fields when writing values to other fields of
the same register. For forward compatibility, implementations that do not furnish these fields must
make them read-only zero. These fields are labeled *WPRI* in the register descriptions.
|Privileged 2.3|Some read/write CSR fields specify behavior for only a subset of possible bit encodings, with other bit encodings reserved. Software should not write anything other than legal values to such a field, and
should not assume a read will return a legal value unless the last write was of a legal value, or the
register has not been written since another operation (e.g., reset) set the register to a legal value.
These fields are labeled *WLRL* in the register descriptions.
|Privileged 2.3|Implementations are permitted but not required to raise an illegal-instruction exception if an
instruction attempts to write a non-supported value to a *WLRL* field. Implementations can return
arbitrary bit patterns on the read of a *WLRL* field when the last write was of an illegal value, but the
value returned should deterministically depend on the illegal written value and the value of the field
prior to the write.
|Privileged 2.3|Some read/write CSR fields are only defined for a subset of bit encodings, but allow any value to be
written while guaranteeing to return a legal value whenever read. Assuming that writing the CSR has no
other side effects, the range of supported values can be determined by attempting to write a desired
setting then reading to see if the value was retained. These fields are labeled *WARL* in the register
descriptions.
|Privileged 2.3|Implementations will not raise an exception on writes of unsupported values to a *WARL* field.
Implementations can return any legal value on the read of a *WARL* field when the last write was of an
illegal value, but the legal value returned should deterministically depend on the illegal written value
and the architectural state of the hart.
|===

== Unprivileged Test Plan

Unprivileged tests exercise every instruction using every applicable source and destination register, and reasonable architectural edge values of sources.  They are intended for certification, not verification. For example, they do not test all difficult floating-point cases.

The unprivileged test plan is written to be easily reviewed by a human, and to be automatically converted to machine-readable coverpoints and tests.
It is defined with spreadsheets in comma-separated value (CSV) format.

=== Unprivileged Tests

Every bin in every coverpoint is associated with a specific test footnote:[cp_asm_count is an exception, just counting the number of times the instruction was executed]. Unprivileged tests sweep some feature under test (such as the destination register rd) while randomizing all applicable register IDs and source values (including values to be loaded from memory).  For example, the unprivileged test for the cp_rd coverpoint of the add instruction contains 32 add instructions, using the 32 different choices of rd.  The rs1 and rs2 register numbers and values are selected randomly. <<Appendix A: Examples>> gives examples of unprivileged coverpoints and tests meeting these requirements and the coverpoints of <<t-I-coverpoints>> for the `add` instruction.  Each test is self-checking, checking the destination register value against one provided by a reference model.  Certain tests also test other state such as stores or floating-point flags, as described in those sections.

[NOTE]
====
The random values are preferably selected in a deterministic way so that regenerating tests use the same random values where possible, minimizing differences between tests.  This can be done by seeding the random number generator with a has of the instruction and coverpoint name.
====

Unprivileged tests are designed to never trap. Their results are independent of the privilege mode in which they are run, so they generally are run only in machine mode.  They generally involve no privileged instructions, except that floating-point and vector tests turn on the mstatus.{FS/VS} bits to enable these extensions.

=== Unprivileged Coverpoints

The coverpoints in <<t-unprivileged-coverpoints>> are used in most of the unprivileged test plans in subsequent sections.

[[t-unprivileged-coverpoints]]
.Coverpoint Definitions
[cols="3,1,10" options=header]
[%AUTOWIDTH]
|===
|Coverpoint|Bins|Definition
3+^|Basic Coverpoints
|cp_asm_count|1|Number of times the instruction is executed in the test, must be greater than 0.
|cp_rs1|32|The rs1 register number used in the instruction.
|cp_rs2|32|The rs2 register number used in the instruction.
|cp_rd|32|The rd register number used in the instruction.
|cp_rs1_edges|16|Edge values for rs1 (see <<t-integer-edge-definitions>>).
|cp_rs2_edges|16|Edge values for rs2 (see <<t-integer-edge-definitions>>).
|cp_imm_edges|16|Edge values for 12-bit immediates (see <<t-immediate-edge-definitions>>).
|cr_rs1_imm_edges|16*20|Cross-product of rs1 and 12-bit immediate edges (see <<t-immediate-edge-definitions>>).
|cr_rs1_rs2_edges|16*16|Cross-product of rs1 and rs2 edges, used for instructions with two source registers.
|cmp_rs1_rs2|32|The rs1 and rs2 registers have the same register number.
|cmp_rd_rs1|32|The rd register has the same register number as the rs1 register.
|cmp_rd_rs2|32|The rd register has the same register number as the rs2 register.
|cmp_rd_rs1_rs2|32|The rd register has the same register number as both the rs1 and rs2 registers.
|cp_offset|2|A branch or jalr instruction has a positive and negative offset.
|cp_uimm|`XLEN`|Exercise all XLEN unsigned immediate values, such as shift amounts.
|cp_align|≤ 8|Alignment of naturally-aligned sub-doubleword load/store operand within doubleword
|cp_gpr_hazard|4|General-purpose register hazard detection: RAW, WAR, WAW, and no hazard.
3+^|Coverpoints for Compressed Instructions
|cp_rs1p|8|The rs1 register number used in compressed instructions supporting x8-x15.
|cp_rs2p|8|The rs2 register number used in compressed instructions supporting x8-x15.
|cp_rdp|8|The rd register number used in compressed instructions supporting x8-x15.
|cp_fdp|8|The fd register number used in compressed floating-point instructions supporting x8-x15.
|cp_fs2p|8|The fs2 register number used in compressed floating-point instructions supporting x8-x15.
|cp_imm_mul|8|7-bit immediate that is a multiple of 4 (for word-sized load/store instructions).
3+^|Coverpoints for Floating-Point Instructions
|cp_fs1|32|The fs1 register number used in the instruction.
|cp_fs2|32|The fs2 register number used in the instruction.
|cp_fs3|32|The fs3 register number used in the instruction.
|cp_fd|32|The fd register number used in the instruction.
|cp_fs1_edges|26|Edge values for fs1 (see <<t-fp-edge-definitions>>)
|cp_fs2_edges|26|Edge values for fs2 (see <<t-fp-edge-definitions>>)
|cp_fs3_edges|26|Edge values for fs3 (see <<t-fp-edge-definitions>>)
|cmp_fd_fs1|32|The fd register has the same register number as the fs1 register.
|cmp_fd_fs2|32|The fd register has the same register number as the fs2 register.
|cmp_fd_fs3|32|The fd register has the same register number as the fs3 register.
|cp_frm|5|The floating-point rounding mode used in the instruction: rne, rdn, rup, rtz, rmm, dyn.
|cp_csr_fflags|10|The instruction sets the {NV, DZ, OF, UF, NX} flags in the fflags CSR.
|cp_csr_frm|6|Dynamic rounding mode in the frm CSR: rne, rdn, rup, rtz, rmm, illegal
|cr_fs1_fs2_edges|26*26|Cross product of edges of fs1 and fs2 registers.
|cr_fs1_fs3_edges|26*26|Cross product of edges of fs1 and fs3 registers.
|cp_fclass|10|All 10 fclass classes.
|cp_NaNBox|1|Upper bits of NaN-boxed value are all 1s
|cp_fs1_badNB|12|The fs1 register contains an incorrectly-NaN-boxed lower-precision value.
|cp_fs2_badNB|12|The fs2 register contains an incorrectly-NaN-boxed lower-precision value.
|cp_fs3_badNB|12|The fs3 register contains an incorrectly-NaN-boxed lower-precision value.
|cp_fpr_hazard|4|Floating-point register hazard detection: RAW, WAR, WAW, and no hazard.
3+^|Miscellaneous Coverpoints
|cp_bs|4|Byte select field for 32-bit AES instructions
|cp_rnum|11|Round nummber for AES instructions
|cp_sc|2|Store conditional instruction has a success and failure case.
|===

Notes:

* These coverpoints are adapted from the Imperas https://github.com/riscv-verification/riscvISACOV[riscvISACOV] functional coverage project.

* Register number is a 5-bit ID (e.g. x7), while register value is an `XLEN`-sized number.

* Most coverpoints typically have 32 bins because they exercise all 32 integer registers.

* Cross-products exercise all combinations of two or more coverpoints. They can have a large number of bins.

* Each of these coverpoints can optionally have a modifer appended.  For example, cp_rs1_nx0 is a modified version of cp_rs1, covering all 31 rs1 register numbers excluding x0.  It is used for load/store/jalr instructions that can't rely on address 0 specified by x0 being legal. Modifiers are defined in the extensions that they apply to.

* The cmp_* and cp_*_hazard coverpoints occupy the fuzzy land at the edge of certification and verification.  They are included because they are easy.

* The riscvISACOV test plan had cmp_rd_{rs1/rs2}_eqval coverpoints that compare if rd and one of the sources have the same value.  These are generally hit by the cr_rs1_rs2_edges tests, so they don't add interesting additional coverage and were dropped.  riscvISACOV also had cp_{rs1/rs2/rd}_toggle tests that checked if each bit changed from 1 to 0 and vice versa.  This is trivially exercised by providing all 0s followed by all 1s followed by al 0s again, so they were dropped.

[[t-integer-edge-definitions]]
.Integer Edge Case Definitions
[options=header]
|===
|Bin|RV32|RV64
|zero    |`00000000000000000000000000000000`|`0000000000000000000000000000000000000000000000000000000000000000`
|one     |`00000000000000000000000000000001`|`0000000000000000000000000000000000000000000000000000000000000001`
|two     |`00000000000000000000000000000010`|`0000000000000000000000000000000000000000000000000000000000000010`
|min     |`10000000000000000000000000000000`|`1000000000000000000000000000000000000000000000000000000000000000`
|minp1   |`10000000000000000000000000000001`|`1000000000000000000000000000000000000000000000000000000000000001`
|max     |`01111111111111111111111111111111`|`0111111111111111111111111111111111111111111111111111111111111111`
|maxm1   |`01111111111111111111111111111110`|`0111111111111111111111111111111111111111111111111111111111111110`
|ones    |`11111111111111111111111111111111`|`1111111111111111111111111111111111111111111111111111111111111111`
|onesm1  |`11111111111111111111111111111110`|`1111111111111111111111111111111111111111111111111111111111111110`
|walkeodd|`10101010101010101010101010101010`|`1010101010101010101010101010101010101010101010101010101010101010`
|walkeven|`01010101010101010101010101010101`|`0101010101010101010101010101010101010101010101010101010101010101`
|random  |`01???????????????????????????010`|`01???????????????????????????????????????????????????????????010`
|Wmax    |n/a|`0000000000000000000000000000000011111111111111111111111111111111`
|Wmaxm1  |n/a|`0000000000000000000000000000000011111111111111111111111111111110`
|Wmaxp1  |n/a|`0000000000000000000000000000000100000000000000000000000000000000`
|Wmaxp2  |n/a|`0000000000000000000000000000000100000000000000000000000000000001`
|===

[[t-immediate-edge-definitions]]
.Immediate Edge Case Definitions (12-bit)
[options=header]
[%autowidth]
|===
|Bin|12-bit Signed Value
|zero|0
|p0|1
|p1|2
|three|3
|p2|4
|p3|8
|p4|16
|p5|32
|p6|64
|p7|128
|p8|256
|p9|512
|hm1|1023
|p10|1024
|max|2047
|min|-2048
|minp1|-2047
|onesm1|-2
|ones|-1
|randomp|1795
|===

[[t-fp-edge-definitions]]
.Floating-Point Edge Case Definitions
[options=header]
|===
|Bin|Half|Float|Double
|pos0|`0000`|`00000000`|`0000000000000000`
|neg0|`8000`|`80000000`|`8000000000000000`
|pos1|`3C00`|`3F800000`|`3FF0000000000000`
|neg1|`BC00`|`BF800000`|`BFF0000000000000`
|pos1p5|`3E00`|`3F000000`|`3FE0000000000000`
|neg1p5|`BE00`|`BF000000`|`BFE0000000000000`
|pos2|`4000`|`40000000`|`4000000000000000`
|neg2|`C000`|`C0000000`|`C000000000000000`
|posminnorm|`0400`|`00800000`|`0010000000000000`
|negminnorm|`8400`|`80800000`|`8010000000000000`
|posmaxnorm|`7BFF`|`7F7FFFFF`|`7FEFFFFFFFFFFFFF`
|negmaxnorm|`FBFF`|`FF7FFFFF`|`FFEFFFFFFFFFFFFF`
|posmax_subnorm|`03FF`|`007FFFFF`|`000FFFFFFFFFFFFF`
|negmax_subnorm|`83FF`|`807FFFFF`|`800FFFFFFFFFFFFF`
|posmid_subnorm|`0200`|`00400000`|`0008000000000000`
|negmid_subnorm|`8200`|`80400000`|`8008000000000000`
|posmin_subnorm|`0001`|`00000001`|`0000000000000001`
|negmin_subnorm|`8001`|`80000001`|`8000000000000001`
|posinfinity|`7C00`|`7F800000`|`7FF0000000000000`
|neginfinity|`FC00`|`FF800000`|`FFF0000000000000`
|posQNaN|`7E00`-`7FFF`|`7FC00000`-`7FFFFFFF`|`7FF8000000000000`-`7FFFFFFFFFFFFFFF`
|posSNaN|`7C01`-`7DFF`|`7F800001`-`7FBFFFFF`|`7FF0000000000001`-`7FF7FFFFFFFFFFFF`
|negQNaN|`FE00`-`FFFF`|`FFC00000`-`FFFFFFFF`|`FFF8000000000000`-`FFFFFFFFFFFFFFFF`
|negSNaN|`FC01`-`FDFF`|`FF800001`-`FFBFFFFF`|`FFF0000000000001`-`FFF7FFFFFFFFFFFF`
|posrandom|`58B4`|`7ef8654f`|`3FF58B4C00000000`
|negrandom|`C93A`|`813d9ab0`|`A6E895993737426C`
|===


[NOTE]
====
The register edge cases are selected to include extreme values and their immediate neighbors.  They also include walking 1s and a random number to exercise intermediate values.  RV64 adds edge casess near the 32-bit boundary to stress W-type instructions.  Immediate edge cases exercise each bit of the immediate, extreme values, and one random intermediate value.
====


=== I Extension

<<t-I-coverpoints>> summarizes the coverpoints for the I extension.  The Type column is used to generate tests with the appropriate operands. An x in the RV32 or RV64 colunn indicates that the instruction is supported in that XLEN.  The remaining columns refer to coverpoints defined in <<t-unprivileged-coverpoints>>.

[[t-I-coverpoints]]
.I Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/I.csv[]
,===

<<t-I-coverpoints>> uses the following coverpoint modifiers:

[[t-I-modified-coverpoints]]
.I Modified Coverpoints
[cols="2, 1, 4" options=header]
|===
|Modified Coverpoint|Bins|Definition
|cp_rs1_nx0|31|The rs1 register number used in the instruction, excluding x0.  x0 is hardwired to 0, which results in potentially access faults for loads, stores, and jalr.
|cmp_rd_rs1_nx0|31|See cp_rs1_nx0
|cp_offset_jalr|6|cp_offset + 2*2 combinations of rs1_val[0] and imm[0] affecting lsb of jalr address
|cp_uimm_5|32|5-bit unsigned immediate shift amount for {slliw/srliw/sraiw}
|cp_imm_edges_20bit|27|20-bit variant of <<t-immediate-edge-definitions>> for `lui` and `auipc`.
|cp_imm_edges_jal|23|20-bit positive and negative jump offsets for `jal`.  Note that testing the full 20-bit range takes a large amount of program memory, so tests may cover a subset of this range.
|cp_gpr_hazard_r|2|RAR and no hazard for instructions that only write a register
|cp_gpr_hazard_w|3|WAW, WAR and no hazard for instructions that only write a register
|cp_gpr_hazard_rw|4|RAW, WAW, WAR and no hazard for instructions that read and write registers
|cp_align_{byte/hword/word}|8/4/2|Alignment of naturally-aligned load/store operand within doubleword in memory
|cp_custom_fence|3|Test that fence, fence rw,rw, and fence.tso all execute without trapping.
|===

<<t-I-normative-statements>> summarizes the normative statements in the RV{32/64}I specification and the unprivileged coverpoints that exercise them.  Privileged coverpoints related to integer instructions are described in the relevent parts of <<Privileged Test Plan>>. Note that the testplans always test the following fundamental capabilities, even if no normative statement is cited:

* Opcodes (cp_asm_count)
* All Source and Destination Registers (cp_rs1, cp_rs2, cp_rd)
* Edge values (cp_rs1_edges, cp_rs2_edges, cp_imm_edges, cr_rs1_rs2_edges, cr_rs1_imm_edges)
* All other bitfields in the instruction

[[t-I-normative-statements]]
.I Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|2.1|For RV32I, the 32 `x` registers are each 32 bits wide, i.e., `XLEN=32`.| cp_rs1, cp_rs2, cp_rd, cp_rs1_edges
|2.1|Register `x0` is hardwired with all bits equal to 0.|cp_rs1, cp_rs2, cp_rd
|2.2|In the base RV32I ISA, there are four core instruction formats (R/I/S/U)|cp_asm_count
|2.2|Except for the 5-bit immediates used in CSR instructions (Chapter 6), immediates are always sign-extended|cp_imm_edges
|2.2|Each immediate subfield is labeled with the bit position (imm[x]) in
the immediate value being produced.|cp_imm_edges
|2.3|The only difference between the S and B formats is that the 12-bit
immediate field is used to encode branch offsets in multiples of 2 in
the B format. Instead of shifting all bits in the instruction-encoded
immediate left by one in hardware as is conventionally done, the middle
bits (imm[10:1]) and sign bit stay in fixed positions, while the lowest
bit in S format (inst[7]) encodes a high-order bit in B format.|{store/branch}/cp_imm_edges
|2.3|[T]he only difference between the U and J formats is that the
20-bit immediate is shifted left by 12 bits to form U immediates and by
1 bit to form J immediates. The location of instruction bits in the U
and J format immediates is chosen to maximize overlap with the other
formats and with each other.|{lui/jalr}/cp_imm_edges
|2.3|Sign extensions always uses inst[31].|cp_imm_edges
|2.4|Most integer computational instructions operate on XLEN bits of values held in the integer register file.|cp_rs1, cp_rs2, cr_rs1_rs2_edges
|2.4|Integer computational instructions are either encoded as register-immediate operations using the I-type format or as register-register operations using the R-type format.|cp_rs1, cp_cp_rs1_imm_edges
|2.4|The destination is register rd for both register-immediate and register-register instructions.|cp_rd
|2.4|No integer computational instructions cause arithmetic exceptions.|untestable
|2.4.1|ADDI adds the sign-extended 12-bit immediate to register _rs1_.
Arithmetic overflow is ignored and the result is simply the low XLEN
bits of the result.|addi/cp_rs1_imm_edges
|2.4.1|SLTI (set less than immediate) places the value 1 in register _rd_ if
register _rs1_ is less than the sign-extended immediate when both are
treated as signed numbers, else 0 is written to _rd_.|slti/cp_rs1_imm_edges
|2.4.1|SLTIU is similar
but compares the values as unsigned numbers (i.e., the immediate is
first sign-extended to XLEN bits then treated as an unsigned number).|sltiu/cp_rs1_imm_edges
|2.4.1|ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
XOR on register _rs1_ and the sign-extended 12-bit immediate and place
the result in _rd_.|{andi/ori/xori}/cp_rs1_imm_edges
|2.4.1|Shifts by a constant are encoded as a specialization of the I-type
format. The operand to be shifted is in _rs1_, and the shift amount is
encoded in the lower 5 bits of the I-immediate field. The right shift
type is encoded in bit 30. SLLI is a logical left shift (zeros are
shifted into the lower bits); SRLI is a logical right shift (zeros are
shifted into the upper bits); and SRAI is an arithmetic right shift (the
original sign bit is copied into the vacated upper bits).|{slli/srli/srai}/cp_rs1_imm_edges, cp_uimm
|2.4.1|LUI (load upper immediate) is used to build 32-bit constants and uses
the U-type format. LUI places the 32-bit U-immediate value into the
destination register _rd_, filling in the lowest 12 bits with zeros.|lui/cp_imm_edges_20bit, cp_rd
|2.4.1|AUIPC (add upper immediate to `pc`) is used to build `pc`-relative
addresses and uses the U-type format. AUIPC forms a 32-bit offset from
the U-immediate, filling in the lowest 12 bits with zeros, adds this
offset to the address of the AUIPC instruction, then places the result
in register _rd_.|auipc/cp_imm_edges_20bit, cp_rd
|2.4.2|RV32I defines several arithmetic R-type operations. All operations read
the _rs1_ and _rs2_ registers as source operands and write the result
into register _rd_. The _funct7_ and _funct3_ fields select the type of
operation.|cr_rs1_rs2_edges, cp_rs1, cp_rs2, cp_rd
|2.4.2|ADD performs the addition of _rs1_ and _rs2_.|add/cp_rs1_rs2_edges
|2.4.2|SUB performs the
subtraction of _rs2_ from _rs1_. Overflows are ignored and the low XLEN
bits of results are written to the destination _rd_. |sub/cp_rs1_rs2_edges
|2.4.2|SLT and SLTU
perform signed and unsigned compares respectively, writing 1 to _rd_ if
_rs1_ < _rs2_, 0 otherwise.|{slt/sltu}/cp_rs1_rs2_edges
|2.4.2|AND, OR, and XOR perform bitwise
logical operations.|{and/or/xor}/cp_rs1_rs2_edges
|2.4.2|SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register _rs1_ by the shift amount held in
the lower 5 bits of register _rs2_.|{sll/srl/sra}/cp_rs1_rs2_edges, cp_rs2
|2.4.3|The NOP instruction does not change any architecturally visible state,
except for advancing the `pc` and incrementing any applicable
performance counters. NOP is encoded as ADDI _x0, x0, 0_.|addi/cp_rs1_imm_edges
|2.5.1|The jump and link (JAL) instruction uses the J-type format, where the
J-immediate encodes a signed offset in multiples of 2 bytes. The offset
is sign-extended and added to the address of the jump instruction to
form the jump target address.|jal/cp_imm_edges_jal
|2.5.1|Plain unconditional jumps (assembler pseudoinstruction J) are encoded as
a JAL with _rd_=`x0`.|jal/cp_rd
|2.5.1|The indirect jump instruction JALR (jump and link register) uses the
I-type encoding. The target address is obtained by adding the
sign-extended 12-bit I-immediate to the register _rs1_, then setting the
least-significant bit of the result to zero. The address of the
instruction following the jump (`pc`+4) is written to register _rd_.
Register `x0` can be used as the destination if the result is not
required.|jalr/{cp_offset_jalr, cp_rd, cp_imm_edges}
|2.5.2|All branch instructions use the B-type instruction format. The 12-bit
B-immediate encodes signed offsets in multiples of 2 bytes. The offset
is sign-extended and added to the address of the branch instruction to
give the target address.|{beq/bne/blt/bge/bltu/bgeu}/cp_offset, *** more via Issue 717
|2.5.2|BEQ and BNE take the branch
if registers _rs1_ and _rs2_ are equal or unequal respectively.|{beq/bne}/cp_rs1_rs2_edges
|2.5.2|BLT and
BLTU take the branch if _rs1_ is less than _rs2_, using signed and
unsigned comparison respectively. |{blt/bltu}/cp_rs1_rs2_edges
|2.5.2|BGE and BGEU take the branch if _rs1_
is greater than or equal to _rs2_, using signed and unsigned comparison
respectively.|{bge/bgeu}/cp_rs1_rs2_edges
|2.6|The effective address is obtained by adding register _rs1_ to the
sign-extended 12-bit offset.|cp_imm_edges
|2.6|Loads copy a value from memory to register
_rd_.|{lb/lbu/lh/lhu/lw}/{cp_rd}
|2.6|Stores copy the value in register _rs2_ to memory.|{sb/sh/sw}/{cp_rs2}
|2.6|The LW instruction loads a 32-bit value from memory into _rd_.|{cp_rd}
|2.6|LH loads
a 16-bit value from memory, then sign-extends to 32-bits before storing
in _rd_. LHU loads a 16-bit value from memory but then zero extends to
32-bits before storing in _rd_. LB and LBU are defined analogously for
8-bit values.|{lh/lhu/lb/lbu}/{cp_rd} hits these with random values.  32 random values is sufficient to ensure sign and zero extension are taking place.
|2.6|The SW, SH, and SB instructions store 32-bit, 16-bit, and
8-bit values from the low bits of register _rs2_ to memory.|{sw/sh/sb}/cp_rs2_edges
|2.6|loads and stores whose effective addresses are
naturally aligned shall not raise an address-misaligned exception.|untestable
|2.7|FENCE instructions are used to order device I/O and memory accesses as
viewed by other RISC-V harts and external devices or coprocessors.|fence/cp_asm_count; behavior untestable from a single core
|2.9|Implementations are always allowed to ignore the
encoded hints.|Untested because they may not be implemented.
3+^|RV64-Specific Statements
|4.1|RV64I widens the integer registers and supported user address space to 64 bits|cp_rs1, cp_rs2, cp_rs1_rs2_edges
|4.2.1|ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign extension of a 32-bit result in rd. Overflows are ignored and the result is the low 32 bits of the result sign-extended to 64 bits.|cp_rs1_imm_edges
|4.2.1|Shifts by a constant are encoded as a specialization of the I-type format using the same instruction opcode as RV32I. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 6 bits of the I-immediate field for RV64I. The right shift type is encoded in bit 30. SLLI is a logical left shift (zeros are shifted into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).|{slli/srli/srai}/cp_rs1_imm_edges, cp_uimm
|4.2.1|SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously
defined but operate on 32-bit values and sign-extend their 32-bit
results to 64 bits.|{slliw/srliw/sraiw}/cp_rs1_imm_edges, cp_uimm
|4.2.1|LUI (load upper immediate) uses the same opcode as RV32I. LUI places the
32-bit U-immediate into register _rd_, filling in the lowest 12 bits
with zeros. The 32-bit result is sign-extended to 64 bits.|lui/cp_imm_edges_20bit, cp_rd
|4.2.1|AUIPC (add upper immediate to `pc`) uses the same opcode as RV32I. AUIPC
is used to build `pc`-relative addresses and uses the U-type format.
AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest
12 bits with zeros, sign-extends the result to 64 bits, adds it to the
address of the AUIPC instruction, then places the result in register
_rd_.|auipc/cp_imm_edges_20bit, cp_rd
|4.2.2|ADDW and SUBW are RV64I-only instructions that are defined analogously
to ADD and SUB but operate on 32-bit values and produce signed 32-bit
results. Overflows are ignored, and the low 32-bits of the result is
sign-extended to 64-bits and written to the destination register.|{addw/subw}/cp_rs1_rs2_edges
|4.2.2|SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register _rs1_ by the shift amount held in
register _rs2_. In RV64I, only the low 6 bits of _rs2_ are considered
for the shift amount.|{sll/srl/sra}/cp_rs1_rs2_edges
|4.2.2|SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
defined but operate on 32-bit values and sign-extend their 32-bit
results to 64 bits. The shift amount is given by _rs2[4:0]_.|{sllw/srlw/sraw}/cp_rs1_rs2_edges, cp_rs2
|4.3|RV64I extends the address space to 64 bits. The execution environment
will define what portions of the address space are legal to access.|untestable
|4.3|The LD instruction loads a 64-bit value from memory into register _rd_
for RV64I.|ld/cp_rd
|4.3|The LW instruction loads a 32-bit value from memory and sign-extends
this to 64 bits before storing it in register _rd_ for RV64I. The LWU
instruction, on the other hand, zero-extends the 32-bit value from
memory for RV64I. LH and LHU are defined analogously for 16-bit values,
as are LB and LBU for 8-bit values.|{lw/lwu/lh/lhu/lb/lbu}/cp_rd, ***sext
|4.3|The SD, SW, SH, and SB instructions
store 64-bit, 32-bit, 16-bit, and 8-bit values from the low bits of
register _rs2_ to memory respectively.|{sd/sw/sh/sb}/cp_rs2_edges
|4.4|The additional computational instructions in RV64I expand both the
standard and custom HINT encoding spaces.|untestable
|===

[[t-I-normative-reserved]]
.I Reserved Behavior
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|4.2.1|SLLIW, SRLIW, and SRAIW encodings with
_imm[5] &#8800; 0_ are reserved.|cp_uimm_5
See also Ssstrict in <<Ssstrict>>

|===

=== M Multiply Extension

<<t-M-coverpoints>> summarizes the coverpoints for the M extension. <<t-M-normative-statements>> summarizes the relevant normative statements.

[[t-M-coverpoints]]
.M Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/M.csv[]
,===

[[t-M-normative-statements]]
.M Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|12.1|MUL performs an XLEN-bit×XLEN-bit multiplication of
`rs1` by `rs2` and places the lower XLEN bits in the destination
register. |mul/{cp_rs1, cp_rs2, cp_rd, cr_rs1_rs2_edges}
|12.1|MULH, MULHU, and MULHSU perform the same multiplication but
return the upper XLEN bits of the full 2×XLEN-bit
product, for signed×signed,
unsigned×unsigned, and `rs1`×unsigned `rs2` multiplication.|{mulh/mulhu/mulhsu}/cr_rs1_rs2_edges
|12.1|MULW is an RV64 instruction that multiplies the lower 32 bits of the
source registers, placing the sign extension of the lower 32 bits of the
result into the destination register.|mulw/cr_rs1_rs2_edges
|12.2|DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned
integer division of `rs1` by `rs2`, rounding towards zero.|{div/divu}/cr_rs1_rs2_edges
|12.2|REM and REMU
provide the remainder of the corresponding division operation. For REM,
the sign of a nonzero result equals the sign of the dividend.|{rem/remu}/cr_rs1_rs2_edges
|12.2|DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of
`rs1` by the lower 32 bits of `rs2`, treating them as signed and
unsigned integers, placing the 32-bit quotient in `rd`,
sign-extended to 64 bits. |{divw/divuw}/cr_rs1_rs2_edges
|12.2|REMW and REMUW are RV64 instructions that
provide the corresponding signed and unsigned remainder operations. Both
REMW and REMUW always sign-extend the 32-bit result
to 64 bits, including on a divide by zero.|{remw/remuw}/cr_rs1_rs2_edges
|12.2|The semantics for division by zero and division overflow are summarized
in <<divby0>>. The quotient of division by zero has all bits
set, and the remainder of division by zero equals the dividend. Signed
division overflow occurs only when the most-negative integer is divided
by latexmath:[$-1$]. The quotient of a signed division with overflow is
equal to the dividend, and the remainder is zero. Unsigned division
overflow cannot occur.|cp_rs1_rs2_edges
|===


==== Zmmul

The Zmmul extension is a subset of the M extension that includes only the multiply instructions.  The coverpoints are listed in <<t-Zmmul-coverpoints>>.

[[t-Zmmul-coverpoints]]
.Zmmul Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zmmul.csv[]
,===

[[t-Zmmul-normative-statements]]
.Zmmul Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|12.3|The `Zmmul` extension implements the multiplication subset of the M
extension. It adds all of the instructions defined in
<<Multiplication Operations>>, namely: MUL, MULH, MULHU,
MULHSU, and (for RV64 only) MULW. The encodings are identical to those
of the corresponding M-extension instructions. |{mul/mulh/mulhu/mulhsu/mulw}/cr_rs1_rs2_edges
|===

=== C Compressed Extension

The C extension is subdivided into Zca, Zcf, and Zcd.  All configurations supporting C contain Zca.  RV32CF configurations also contain Zcf, and RV{32/64}CD configurations also contain Zcd.  A configuration supporting C should test all of the applicable Zc* extensions. <<t-C-normative-statements>> lists the normative statements in the RV{32/64}C specification applicable to all instructions, and the unprivileged coverpoints that exercise them.  Normative statements related to privileged behavior of C instructions are given in <<

[[t-C-normative-statements]]
.C Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|27.1|The C extension allows
16-bit instructions to be freely intermixed with 32-bit instructions, with the latter now able to start on
any 16-bit boundary, i.e., IALIGN=16.|***
|27.1|The compressed instruction encodings are mostly common across RV32C and
RV64C, but as shown in <<rvc-instr-table0, Table 34>>, a few opcodes are used for
different purposes depending on base ISA.|Run relevant test suites.
|27.1|If the C extension is implemented, the appropriate compressed
floating-point load and store instructions must be provided whenever the relevant standard floating-
point extension (F and/or D) is also implemented.|Run relevant test suites.
|27.2|CR, CI, and CSS can use any of the 32 RVI registers, but CIW,
CL, CS, CA, and CB are limited to just 8 of them.|cp_rs1p, cp_rs2p, cp_rdp
|27.2|Compressed register-based floating-point loads and stores also use the
CL and CS formats respectively, with the eight registers mapping to `f8` to `f15`.|cp_fdp, cp_fs2p
|27.2|For many RVC instructions, zero-valued immediates are disallowed and
`x0` is not a valid 5-bit register specifier.|cp_rs1_imm_edges,cp_imm_mul, _nx0 coverpoints
|27.4|As with base RVI instructions, the offsets of all RVC
control transfer instructions are in multiples of 2 bytes.|***
|27.7|A portion of the RVC encoding space is reserved for microarchitectural
HINTs. ...these instructions do not
modify any architectural state, except for advancing the `pc` and any
applicable performance counters. HINTs are executed as no-ops on
implementations that ignore them.|Hints are not tested
|===

***move***

[[t-C-priv-normative-statements]]
.C Privileged Normative Statements
[cols="1, 4, 2" options=header]
|===
|Section|Normative Statement|Coverpoints
|Unpriv 2.5.2|Instruction-address-misaligned exceptions are not possible on machines
that support extensions with 16-bit aligned instructions, such as the
compressed instruction-set extension, C.| ***
|Unpriv 27.1|With the addition of the C extension, no instructions can raise
instruction-address-misaligned exceptions.|***
|Unpriv 27.5.4|A 16-bit instruction with all bits zero is permanently reserved as an illegal instruction.|***
|Unpriv 27.5.4|Debuggers can use the `C.EBREAK` instruction, which expands to `ebreak`,
to cause control to be transferred back to the debugging environment.
`C.EBREAK` shares the opcode with the `C.ADD` instruction, but with _rd_ and
_rs2_ both zero, thus can also use the `CR` format.|***
|Unpriv 28.4|MISA.C is set if the following extensions are selected:|***read MISA
|===

***
On implementations that support the C extension, compressed forms of the
I instructions permitted inside constrained LR/SC sequences, as
described in <<sec:lrscseq>>, are also permitted
inside constrained LR/SC sequences.

==== Zca Compressed Extension

<<t-Zca-coverpoints>> summarizes the coverpoints for the Zca extension.

[[t-Zca-coverpoints]]
.Zca Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zca.csv[]
,===

*** update all coverpoint refs

[[t-Zca-normative-statements]]
.Zca Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|27.3.1|C.LWSP loads a 32-bit value from memory into register rd. It computes an effective address by adding
the zero-extended offset, scaled by 4, to the stack pointer, x2. It expands to lw rd, offset(x2). C.LWSP
is valid only when rd≠x0; the code points with rd=x0 are reserved.|c.lwsp/***
|27.3.1|C.LDSP is an RV64C-only instruction that loads a 64-bit value from memory into register rd. It
computes its effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2.
It expands to ld rd, offset(x2). C.LDSP is valid only when rd≠x0; the code points with rd=x0 are
reserved.|c.ldsp/*** */
|27.3.1|C.SWSP stores a 32-bit value in register rs2 to memory. It computes an effective address by adding
the zero-extended offset, scaled by 4, to the stack pointer, x2. It expands to sw rs2, offset(x2).|c.swsp/***
|27.3.1|C.SDSP is an RV64C-only instruction that stores a 64-bit value in register rs2 to memory. It computes
an effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It
expands to sd rs2, offset(x2).|c.sdsp/***
|27.3.2|C.LW loads a 32-bit value from memory into register
`_rd′_`. It computes an effective address by adding the
_zero_-extended offset, scaled by 4, to the base address in register
`_rs1′_`. It expands to `lw rd′, offset(rs1′)`.|c.lw/{}
|27.3.2|C.LD is an RV64C-only instruction that loads a 64-bit value from
memory into register `_rd′_`. It computes an effective
address by adding the _zero_-extended offset, scaled by 8, to the base
address in register `_rs1′_`. It expands to
`ld rd′, offset(rs1′)`.|c.ld/{}
|27.3.2|C.SW stores a 32-bit value in register rs2′ to memory. It computes an effective address by adding the
zero-extended offset, scaled by 4, to the base address in register rs1′. It expands to sw rs2′, offset(rs1′).|c.sw/{}
|27.3.2|C.SW stores a 32-bit value in register `_rs2′_` to memory.
It computes an effective address by adding the _zero_-extended offset,
scaled by 4, to the base address in register `_rs1′_`. It
expands to `sw rs2′, offset(rs1′)`.|c.sw/{}
|27.3.2|C.SD is an RV64C-only instruction that stores a 64-bit value in
register `_rs2′_` to memory. It computes an effective
address by adding the _zero_-extended offset, scaled by 8, to the base
address in register `_rs1′_`. It expands to
`sd rs2′, offset(rs1′)`.|c.sd/{}
|27.4|C.J performs an unconditional control transfer. The offset is
sign-extended and added to the `pc` to form the jump target address. C.J
can therefore target a &#177;2 KiB range. C.J expands to
`jal x0, offset`.|c.j/{}
|27.4|C.JAL is an RV32C-only instruction that performs the same operation as
C.J, but additionally writes the address of the instruction following
the jump (`pc+2`) to the link register, `x1`. C.JAL expands to
`jal x1, offset`.|c.jal/{}
|27.4|C.JR (jump register) performs an unconditional control transfer to the
address in register _rs1_. C.JR expands to `jalr x0, 0(rs1)`. C.JR is
valid only when _rs1_≠`x0`; the code
point with _rs1_=`x0` is reserved.|c.jr/{}
|27.4|C.JALR (jump and link register) performs the same operation as C.JR, but
additionally writes the address of the instruction following the jump
(`pc`+2) to the link register, `x1`. C.JALR expands to
`jalr x1, 0(rs1)`. C.JALR is valid only when
_rs1_≠`x0`; the code point with
_rs1_=`x0` corresponds to the C.EBREAK
instruction.|c.jalr/{}, c.ebreak/***
|27.4|C.BEQZ performs conditional control transfers. The offset is
sign-extended and added to the `pc` to form the branch target address.
It can therefore target a &#177;256 B range. C.BEQZ takes the
branch if the value in register _rs1′_ is zero. It
expands to `beq rs1′, x0, offset`.|c.beqz/{}
|27.4|C.BNEZ is defined analogously, but it takes the branch if
_rs1′_ contains a nonzero value. It expands to
`bne rs1′, x0, offset`.|c.bnez/{}
|27.5.1|C.LI loads the sign-extended 6-bit immediate, _imm_, into register _rd_.
C.LI expands into `addi rd, x0, imm`.
The C.LI code points with _rd_=`x0` are HINTs.|c.li/{}
|27.5.1|C.LUI loads the non-zero 6-bit immediate field into bits 17–12 of the
destination register, clears the bottom 12 bits, and sign-extends bit 17
into all higher bits of the destination. C.LUI expands into
`lui rd, imm`. C.LUI is valid only when
_rd_≠`x2`,
and when the immediate is not equal to zero. The code points with
_imm_=0 are reserved.|c.lui/{}
|27.5.2|C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in register rd then writes the
result to rd. C.ADDI expands into addi rd, rd, imm. C.ADDI is valid only when rd≠x0 and imm≠0.|c.addi/{}
|27.5.2|C.ADDIW is an RV64C-only instruction that performs the same
computation but produces a 32-bit result, then sign-extends result to 64
bits. C.ADDIW expands into `addiw rd, rd, imm`. The immediate can be
zero for C.ADDIW, where this corresponds to `sext.w rd`.|c.addiw/{}
|27.5.2|C.ADDI16SP (add immediate to stack pointer)
shares the opcode with C.LUI, but has a destination field of
`x2`. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to the
value in the stack pointer (`sp=x2`), where the immediate is scaled to
represent multiples of 16 in the range [-512, 496]. C.ADDI16SP is used to
adjust the stack pointer in procedure prologues and epilogues. It
expands into `addi x2, x2, nzimm[9:4]`. C.ADDI16SP is valid only when
_nzimm_≠0; the code point with _nzimm_=0 is reserved.|c.addi16sp/{}
|27.5.2|C.ADDI4SPN (add immediate to stack pointer, non-destructive)
is a CIW-format instruction that adds a _zero_-extended
non-zero immediate, scaled by 4, to the stack pointer, `x2`, and writes
the result to `rd′`. This instruction is used to generate
pointers to stack-allocated variables, and expands to
`addi rd′, x2, nzuimm[9:2]`. C.ADDI4SPN is valid only when
_nzuimm_≠0; the code points with _nzuimm_=0 are
reserved.|c.addi4spn/{}
|27.5.2|C.SLLI is a CI-format instruction that performs a logical left shift of
the value in register _rd_ then writes the result to _rd_. The shift
amount is encoded in the _shamt_ field.
C.SLLI expands into `slli rd, rd, shamt[5:0]`.|c.slli/{}
|27.5.2|C.SRLI is a CB-format instruction that performs a logical right shift of
the value in register _rd′_ then writes the result to
_rd′_. The shift amount is encoded in the _shamt_ field.
C.SRLI expands into `srli rd′, rd′, shamt`.|c.srli/{}
|27.5.2|C.SRAI is defined analogously to C.SRLI, but instead performs an
arithmetic right shift. C.SRAI expands to
`srai rd′, rd′, shamt`.|c.srai/{}
|27.5.2|For RV32C, _shamt[5]_ must be zero; the code points with _shamt[5]_=1
are designated for custom extensions.|c.{slli,srli, srai}/{}
|27.5.2|C.ANDI is a CB-format instruction that computes the bitwise AND of the
value in register _rd′_ and the sign-extended 6-bit
immediate, then writes the result to _rd′_. C.ANDI
expands to `andi rd′, rd′, imm`.|c.andi/{}
|27.5.3|C.MV copies the value in register _rs2_ into register _rd_. C.MV expands
into `add rd, x0, rs2`. C.MV is valid only when
_rs2_≠`x0`|c.mv/{}
|27.5.3|C.ADD adds the values in registers _rd_ and _rs2_ and writes the result
to register _rd_. C.ADD expands into `add rd, rd, rs2`. C.ADD is only
valid when _rs2_≠`x0`|c.add/{}
|27.5.3|`C.AND` computes the bitwise `AND` of the values in registers
_rd′_ and _rs2′_, then writes the result
to register _rd′_. `C.AND` expands into
`and rd′, rd′, rs2′`.|c.and/{}
|27.5.3|`C.OR` computes the bitwise `OR` of the values in registers
_rd′_ and _rs2′_, then writes the result
to register _rd′_. `C.OR` expands into
`or rd′, rd′, rs2′`.|c.or/{}
|27.5.3|`C.XOR` computes the bitwise `XOR` of the values in registers
_rd′_ and _rs2′_, then writes the result
to register _rd′_. `C.XOR` expands into
`xor rd′, rd′, rs2′`.|c.xor/{}
|27.5.3|`C.SUB` subtracts the value in register _rs2′_ from the
value in register _rd′_, then writes the result to
register _rd′_. `C.SUB` expands into
`sub rd′, rd′, rs2′`.|c.sub/{}
|27.5.3|`C.ADDW` is an RV64C-only instruction that adds the values in
registers _rd′_ and _rs2′_, then
sign-extends the lower 32 bits of the sum before writing the result to
register _rd′_. `C.ADDW` expands into
`addw rd′, rd′, rs2′`.|c.addw/{}
|27.5.3|`C.SUBW` is an RV64C-only instruction that subtracts the value in
register _rs2′_ from the value in register
_rd′_, then sign-extends the lower 32 bits of the
difference before writing the result to register _rd′_.
`C.SUBW` expands into `subw rd′, rd′, rs2′`.
|27.5.6|`C.NOP` is a CI-format instruction that does not change any user-visible
state, except for advancing the `pc` and incrementing any applicable
performance counters. `C.NOP` expands to `nop`.|c.nop/{}
|===



==== Zcf Compressed Floating-Point Extension

<<t-Zcf-coverpoints>> summarizes the coverpoints for the Zcf extension.

[[t-Zcf-coverpoints]]
.Zcf Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zcf.csv[]
,===

[[t-Zcf-normative-statements]]
.Zcf Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|27.3.1|C.FLWSP is an RV32FC-only instruction that loads a single-precision floating-point value from memory
into floating-point register rd. It computes its effective address by adding the zero-extended offset,
scaled by 4, to the stack pointer, x2. It expands to flw rd, offset(x2).|c.flwsp/***
|27.3.1|C.FSWSP is an RV32FC-only instruction that stores a single-precision floating-point value in floating-
point register rs2 to memory. It computes an effective address by adding the zero-extended offset,
scaled by 4, to the stack pointer, x2. It expands to fsw rs2, offset(x2).|c.fswsp/***
|27.3.2|C.FLW is an RV32FC-only instruction that loads a single-precision
floating-point value from memory into floating-point register
`_rd′_`. It computes an effective address by adding the
_zero_-extended offset, scaled by 4, to the base address in register
`_rs1′_`. It expands to
`flw rd′, offset(rs1′)`.|c.flw/{}
|27.3.2|C.FSW is an RV32FC-only instruction that stores a single-precision
floating-point value in floating-point register `_rs2′_` to
memory. It computes an effective address by adding the _zero_-extended
offset, scaled by 4, to the base address in register
`_rs1′_`. It expands to
`fsw rs2′, offset(rs1′)`.|c.fsw/{}

|===


==== Zcd Compressed Double-Precision FP Extension

<<t-Zcd-coverpoints>> summarizes the coverpoints for the Zcd extension.

[[t-Zcd-coverpoints]]
.Zcd Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zcd.csv[]
,===

[[t-Zcd-normative-statements]]
.Zcd Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|27.3.1|C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision floating-point value
from memory into floating-point register rd. It computes its effective address by adding the zero
-extended offset, scaled by 8, to the stack pointer, x2. It expands to fld rd, offset(x2).|c.fldsp/***
|27.3.1|C.FSDSP is an RV32DC/RV64DC-only instruction that stores a double-precision floating-point value in
floating-point register rs2 to memory. It computes an effective address by adding the zero-extended
offset, scaled by 8, to the stack pointer, x2. It expands to fsd rs2, offset(x2).|c.fsdsp/***
|27.3.2|C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision
floating-point value from memory into floating-point register
`_rd′_`. It computes an effective address by adding the
_zero_-extended offset, scaled by 8, to the base address in register
`_rs1′_`. It expands to
`fld rd′, offset(rs1′)`.|c.fld/{}
|27.3.2|C.FSD is an RV32DC/RV64DC-only instruction that stores a
double-precision floating-point value in floating-point register
`_rs2′_` to memory. It computes an effective address by
adding the _zero_-extended offset, scaled by 8, to the base address in
register `_rs1′_`. It expands to
`fsd rs2′, offset(rs1′)`.|c.fsd/{}
|===

==== Zcb Additional Compressed Instructions

<<t-Zcb-coverpoints>> summarizes the coverpoints for the Zcb extension.

[[t-Zcb-coverpoints]]
.Zcb Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zcb.csv[]
,===

[[t-Zcb-normative-statements]]
.Zcb Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|28.12.1|c.lbu lloads a byte from the memory address formed by adding _rs1'_ to the zero extended immediate _uimm_. The resulting byte is zero extended to XLEN bits and is written to _rd'_.|c.lbu/{}
|28.12.2|c.lhu loads a halfword from the memory address formed by adding _rs1'_ to the zero extended immediate _uimm_. The resulting halfword is zero extended to XLEN bits and is written to _rd'_.|c.lhu/{}
|28.12.3|c.lh loads a halfword from the memory address formed by adding _rs1'_ to the zero extended immediate _uimm_. The resulting halfword is sign extended to XLEN bits and is written to _rd'_.|c.lh/{}
|28.12.4|c.sb stores the least significant byte of _rs2'_ to the memory address formed by adding _rs1'_ to the zero extended immediate _uimm_.|c.sb/{}
|28.12.5|c.sh stores the least significant halfword of _rs2'_ to the memory address formed by adding _rs1'_ to the zero extended immediate _uimm_.|c.sh/{}
|28.12.6|c.zext.b takes a single source/destination operand.
It zero-extends the least-significant byte of the operand to XLEN bits by inserting zeros into all of
the bits more significant than 7.|c.zext.b/{}
|28.12.11|c.not takes the one's complement of _rd'/rs1'_ and writes the result to the same register.|c.not/{}
|===

===== ZcbM

When both Zcb and M are supported, add the instruction in <<t-ZcbM-coverpoints>> to the Zcb coverpoints.

[[t-ZcbM-coverpoints]]
.ZcbM Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZcbM.csv[]
,===

[[t-ZcbM-normative-statements]]
.ZcbM Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|28.12.12|c.mul multiplies XLEN bits of the source operands from _rsd'_ and _rs2'_ and writes the lowest XLEN bits of the result to _rsd'_.|c.mul/{}
|===

===== ZcbZba

When both Zcb and Zba are supported, add the instruction in <<t-ZcbZba-coverpoints>> to the Zcb coverpoints.

[[t-ZcbZba-coverpoints]]
.ZcbZba Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZcbZba.csv[]
,===

[[t-ZcbZba-normative-statements]]
.ZcbZba Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|28.12.10|c.zext.w takes a single source/destination operand.
It zero-extends the least-significant word of the operand to XLEN bits by inserting zeros into all of
the bits more significant than 31.|c.zext.w/{}
|===
===== ZcbZbb

When both Zcb and Zbb are supported, add the instructions in <<t-ZcbZbb-coverpoints>> to the Zcb coverpoints.

[[t-ZcbZbb-coverpoints]]
.ZcbZbb Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZcbZbb.csv[]
,===

[[t-ZcbZbb-normative-statements]]
.ZcbZbb Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|28.12.7|c.sext.b takes a single source/destination operand. It sign-extends the least-significant byte in
the operand to XLEN bits by copying the most-significant bit in the byte (i.e., bit 7) to all of the more-
significant bits.|c.sext.b/{}
|28.12.8|c.zext.h takes a single source/destination operand. It zero-extends the least-significant
halfword of the operand to XLEN bits by inserting zeros into all of the bits more significant than 15.|c.zext.h/{}
|28.12.9|c.sext.h takes a single source/destination operand.
It sign-extends the least-significant halfword in the operand to XLEN bits by copying the most-significant bit
in the halfword (i.e., bit 15) to all of the more-significant bits.|c.sext.h/{}
|===

=== Floating-Point Extensions

Supporting floating-point involves enabling at least the F extension.  Other extensions depend on F.  The coverpoints are specified in the following sections. Some tests only apply when multiple extensions are supported.

==== F Single-Precision FP

[[t-F-coverpoints]]
.F Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/F.csv[]
,===


==== D Double-Precision FP

[[t-D-coverpoints]]
.D Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/D.csv[]
,===


==== Zfh Half-Precision FP

[[t-Zfh-coverpoints]]
.Zfh Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zfh.csv[]
,===


===== ZfhD

[[t-ZfhD-coverpoints]]
.ZfhD Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZfhD.csv[]
,===


===== Zfhmin

[[t-Zfhmin-coverpoints]]
.Zfhmin Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zfhmin.csv[]
,===


===== ZfhminD

[[t-ZfhminD-coverpoints]]
.ZfhminD Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZfhminD.csv[]
,===
å

==== Zfa Additional FP

*** called ZfaF
[[t-ZfaF-coverpoints]]
.ZfaF Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZfaF.csv[]
,===



===== ZfaD

[[t-ZfaD-coverpoints]]
.ZfaD Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZfaD.csv[]
,===


===== ZfaZfh

[[t-ZfaZfh-coverpoints]]
.ZfaZfh Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZfaZfh.csv[]
,===

===== ZfaZfhD

[[t-ZfaZfhD-coverpoints]]
.ZfaZfhD Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/ZfaZfhD.csv[]
,===


=== Zb* Bit Manipulation Extensions

***B=Zba+Zbb+Zbs

==== Zba Bit-Manipulation for Addressing

[[t-Zba-coverpoints]]
.Zba Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zba.csv[]
,===

==== Zbb Basic Bit-Manipulation

[[t-Zbb-coverpoints]]
.Zbb Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zbb.csv[]
,===

==== Zbc Carry-less Multiplication

[[t-Zbc-coverpoints]]
.Zbc Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zbc.csv[]
,===


==== Zbs Single-Bit Manipulation

[[t-Zbs-coverpoints]]
.Zbs Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zbs.csv[]
,===


==== Zbkb Bit-Manipulation for Cryptography

[[t-Zbkb-coverpoints]]
.Zbkb Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zbkb.csv[]
,===


==== Zbkc Carry-less Multiplication for Cryptography

[[t-Zbkc-coverpoints]]
.Zbkc Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zbkc.csv[]
,===


==== Zbkx Permutation

[[t-Zbkx-coverpoints]]
.Zbkx Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zbkx.csv[]
,===

=== Zk*  Cryptographic Extensions

==== Zkne NIST AES Encryption

[[t-Zkne-coverpoints]]
.Zkne Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zkne.csv[]
,===


==== Zknd NIST AES Decryption

[[t-Zknd-coverpoints]]
.Zknd Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zknd.csv[]
,===


==== Zknh NIST SHA2 Hashing

[[t-Zknh-coverpoints]]
.Zknh Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zknh.csv[]
,===


=== Zicond Conditional Instructions

[[t-Zicond-coverpoints]]
.Zicond Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zicond.csv[]
,===

=== Zihintpause Pause Hint

[[t-Zihintpause-coverpoints]]
.Zihintpause Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zihintpause.csv[]
,===

=== Zicsr Control/Status Register Instructions

[[t-Zicsr-coverpoints]]
.Zicsr Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zicsr.csv[]
,===


=== Zifencei Instruction-Fetch Fence

[[t-Zifencei-coverpoints]]
.Zifencei Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zifencei.csv[]
,===


=== V Vector Extension

The vector coverpoints are intended to be flexible to support the full V extension, the Zve* embedded vector extensions, and arbitrary mixes of supported vector length (VLEN), element lengths (SEW~MIN~, ELEN), and floating-point precisions.

The vector extension is huge.  The testplan is partitioned into three unprivileged portions discussed here, and three privileged portions (ZicsrV, ExceptionsV, SsstrictV) discussed in XREF.

The full V extension supports all selected element widths SEW={8, 16, 32, 64}.  The vector coverage files and tests are organized by SEW.  Thus, a DUT could handle any contiguous subset of SEW from SEW~MIN~ to ELEN.  For example, a DUT with SEW~MIN~=16 and ELEN=32 would support SEW={16, 32}.

The tests detect VLMAX and set the vector length accordingly, up to some configurable maximum VLEN (default 4096 bits, although the vector extension theoretically supports up to 65536).  Therefore, there is no need for different test suites for different VLENs.

==== Vector File Organization

<<f-vector-organization>> summarizes the structure of the coverpoint and test files for the vector extension.  The unprivileged vector tests are organized by integer (Vx), load/store (Vls), and floating-point (Vf) types of instructions. Each applies to SEW=8, 16, 32, and/or 64. The ExceptionsV, ZicsrV, and SsstrictV privileged tests are described in section XREF.

The vector tests are organized by XLEN=32 and XLEN=64 because the scalar registers behavior differs by XLEN.  For example, vadd.vx with SEW=64 sign-extends XLEN=32 scalar registers but does not modify XLEN=64 scalar registers.  For a given XLEN, the vector tests are organized by type (Vx/Vls/Vf) and SEW (8/16/32/64).  Each directory contains a .S file for every vector instruction of that type footnote:[Certain instructions are omitted if not supported for a given SEW.  For example, widening add vwadd.vv is not supported for SEW=64, and vrgatherei16.v is not supported for SEW=8.].  Vector load/store instructions run with any SEW but also specify EEW as part of the instruction name.  For example, vle8.v and vle16.v can both be executed in either SEW=8 or SEW=16, and the EMUL behavior is different between these modes.  Therefore, all the load/store variants are included in all of Vls{8/16/32/64}.

[NOTE]
====
Vx and Vf are separated because certain extensions such as Zve64x do not support
floating-point.  Vls could be lumped with Vx, but the coverpoints are so different that
it is easier to define the tests separately, and facilitates just running integer vs. load/store tests during development.
====

[[f-vector-organization]]
.Vector Organization
----
fcov
    unpriv
        Vx8_coverage.svh
        Vx16_coverage.svh
        Vx32_coverage.svh
        Vx64_coverage.svh
        Vls8_coverage.svh
        Vls16_coverage.svh
        Vls32_coverage.svh
        Vls64_coverage.svh
        Vf16_coverage.svh
        Vf32_coverage.svh
        Vf64_coverage.svh
      priv
        ExceptionsV_coverage.svh
        ZicsrV_coverage.svh
        SsstrictV_coverage.svh
tests
    rv32
        Vx8
            vadd.vv.S
            vadd.vx.S
            vadd.vi.S
            vsub.vv.S
            ...
        Vx16
            vadd.vv.S
            ...
        Vx32
            vadd.vv.S
            ...
        Vx64
            vadd.vv.S
            ...
        Vls8
            vle8.v.S
            vle16.v.S
            vle32.v.S
            vle64.v.S
            vlseg2e8.v.S
            ...
        Vls16
            vle8.v.S
            ...
        Vls32
            vle8.v.S
            ...
        Vls64
            vle8.v.S
            ...
        Vf16
            vfadd.vv.S
            vfadd.vf.S
            vfwadd.vv.S
            vfsub.vv.S
            ...
        Vf32
            vfadd.vv.S
            ...
        Vf64
            vfadd.vv.S
            ...
    rv64
        Vx8
        Vx16
        Vx32
        Vx64
        Vls8
        Vls16
        Vls32
        Vls64
        Vf16
        Vf32
        Vf64
    priv
        ExceptionsV.S
        ZicsrV.S
        SsstrictV.S
----

When an instruction's EEW is not a supported SEW, the coverage files and tests exclude the instruction from testing.  For example, vwadd.vv is not supported when SEW=32 and ELEN = 32 because it cannot widen to 64 bits.

The tests also account for unsupported register group overlap.  For example, a widening add vwadd.wv v0, v2, v2 is unspported because the source registers cannot be read with different EEWs.  On the other hand vwadd.vv v0, v1, v8 with LMUL=1 is supported even though the destination vd=v0 widens to write [v0-v1], which overlaps with vs2=v1.  The tests exercise all supported overlaps, but do not attempt any unsupported overlaps because the behavior is reserved and unpredictable.

==== Vector Configuration Parameters

The coverpoints and tests are parameterized by the minimum supported element width SEW~MIN~ and the maximum supported element width ELEN.  The coverpoints and tests exclude unsupported edge cases, such as widening to more than ELEN or using LMUL=1/8 with ELEN=32 but SEW~MIN~=8.

==== Vector Coverpoints

Running long vectors is computationally expensive, so only a subset of vectors tests run on mult-element vectors.  Coverpoints for source and destination registers, edge values, etc. run on a vector length of vl = 1.

<<t-vector-coverpoints>> defines the coverpoints used in vector instructions.  Unless otherwise specified, each coverpoint uses vector length vl=1 and length multiplier LMUL=1, no mask (vm=1), and vstart=0. Hence, they act on exactly one vector element. For such coverpoints, instructions that require a mask use v0=0.

[[t-vector-coverpoints]]
.Vector Coverpoint Definitions
[cols="2,1,5" options=header]
[%AUTOWIDTH]
|===
|Coverpoint|# Bins|Definition
3+^|Coverpoints acting on single element vl=1
|cp_vd|32|All vector destination registers vd=0-31
|cp_vs2|32|All vector source registers vs2=0-31
|cp_vs1|32|All vector source registers vs1=0-31
|cp_vs3|32|All vector source registers vs3=0-31
|cp_rs1|32|All scalar registers rs1=0-31
|cp_rs2|32|All scalar registers rs2=0-31
|cp_imm_5bit|32|Signed immediate values -16 to +15
|cmp_rs1_rs2|32|rs1 and rs2 are same register ID
|cmp_vd_vs2|32|vd and vs2 are same register ID
|cmp_vd_vs1|32|vd and vs1 are same register ID
|cmp_vs2_vs1|32|vs2 and vs1 are same register ID
|cmp_vs3_vs2|32|vs3 and vs2 are the same register ID
|cmp_vd_vs1_vs2|32|vd and vs1 and vs2 are same register ID
|cp_rs1_edges|9|0, 1, 2, -1, -2, most negative, most negative+1, most positive, most positive-1
|cp_rs2_edges|5|0, 1, 2, -1, -2 (for strided vector load/store)
|cp_fs1_edges|20|0, -1, -smallest subnorm, -inf, 1, 1+ulp, 0.5, 1.5, 2, 4, pi, 2^emax, largest normal, smallest normal, largest subnormal, subnormal with leading 1 in fraction, infinity, canonical quite NaN, noncanonical quiet NaN, signaling NaN with payload of 1
|cp_vs2_edges|9 or 20|see cp_rs1_edges or cp_fs1_edges
|cp_vs1_edges|9 or 20|see cp_rs1_edges
|cr_vs2_vs1_edges|9^2 or 20^2|Cross-product of edges of vs2 and vs1
|cr_vs2_rs1_edges|9*9|Cross-product of edges of vs2 and rs1
|cr_vs2_fs1_edges|20*20|Cross-product of edges of vs2 and fs1
|cr_vs2_imm_edges|9*9|Cross-product of edges of vs2 and imm={0, 1, 2, 14, 15, -1, -2, -15,-16}
|cr_vxrm_vs2_vs1_edges|9*9*4|Cross-product of edges of vs2 and vs1 with vector rounding mode={rod, rdn, rne, rnu}
|cr_vxrm_vs2_rs1_edges|9*9*4|See cr_vxrm_vs2_vs1_edges
|cr_vxrm_vs2_imm_edges|9*9*4|See cr_vxrm_vs2_vs1_edges
|cp_csr_frm|5*10|Floating-point rounding mode={rdn, rmm, rne, rtz, rup} with 10 random inputs per mode
|cp_csr_fflags|5*2|Floating-point sets and clears all applicable flags
3+^|Coverpoints acting on multiple elements vl ≠ 1
|cp_masking_edges|5|Mask edge cases v0=all 1s, all 0s, random, first VLMAX-1 ones, first VLMAX/2+1 ones; vl=VLMAX, vm=1 to mask, vma = random, vta = 0
|cr_vl_lmul|7*3|Cross legal combinations of LMUL={1/2/4/8/f2/f4/f8} and vl={1, random, VLMAX}, while randomizing v0 mask value, vm, vta, vma.
|cr_vtype_agnostic|4|Cross vta={0/1} and vma={0/1}. Random legal LMUL, random legal vl, vm=1, v0=random mask
|cp_vxsat|2|vxsat={0, 1}.  Hit by cr_vs2_vs1_edges so no tests needed.
|cp_vl_0|1|vl=0.  LMUL=1, no mask, vma=0, vta=1
|===

As with other unprivileged testplans, an x in the spreadsheet indicates to use the coverpoint.  Other values in the spreadsheet indicate a variant of the coverpoint:

* nv0: Do not include v0 in the coverpoint.  For example, cp_vd_nv0 means that the destination register vd does not include v0.
* emul2: Only exercise even-numbered registers.  For example cp_vs2_emul2 uses vs2={v0, v2, v4, ...v30}.  For edge values, emul2 means the edge value is twice the width of SEW.
* emul4/8: Similar to emul2
* emulf2, emulf4, emulf8: edge values are 1/2, 1/4, or 1/8 the width of SEW.  Used in extension instructions such as vsext.vf2.
* u: Treat immediate as unsigned 0 to 31 rather than signed -16 to +15. For edge values, {0, 1, 2, 15, 16, 30, 31}.
* eew1/mm: Mask instructions with 1-bit elements such as vmand.mm use at least vl=8 to operate on multi-bit masks.
* wv: vs2 is double-width and uses emul2 for its edge values.  vs1 is normal width.
* wred: vs1 is double-width and uses emul2 for its edge values.  vs2 is normal width.
* wx: vs2 is double-width and uses emul2 for its edge values.  rs1 is normal width.
* wi/wiu: vs2 is double-width and uses emul2 for its edge values.  immediate is 5 bit signed or unsigned.
* lmul4max/emul4max: maximum LMUL/EMUL is 4 instead of 8.  vwadd.vv uses lmul4max because it cannot accept LMUL=8 widened to 16.  vlseg2e8.v uses emul4max because the number of segments * EMUL cannot exceed 8.
* lmul2max/lmul1max/emul2max/emul1max: see lmul4max
* lte30/.../lte24: Register number is less than or equal to 30, ..., 24.  Used for segmented load/store so segments won't overflow the register file.
* ls_e{8/16/32/64}: load/store edges with EEW=8,...,64.  Used to convert strided loads from elements to bytes.
* ls: load/store edges instead of integer edges: vs2={0, random < 2*VLMAX}.  rs2= {1, 2, -1, -2, 0}
* f: floating-point edges instead of integer edges: ***

*** discuss special cases

The coverpoints for each vector instruction are given in the following sections.

==== Vx

The Vx testplan is the same for SEW={8, 16, 32, 64}.  Each SEW has its own coverage file (e.g. Vx8_coverages.svh) independent of XLEN, as well as tests that depend on XLEN (e.g. rv32/Vx8/vadd.vx.S).

[[t-Vx-coverpoints]]
.Vx Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Vx.csv[]
,===

==== Vls

[[t-Vls-coverpoints]]
.Vls Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Vls.csv[]
,===

==== Vf

[[t-Vf-coverpoints]]
.Vf Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Vf.csv[]
,===

=== Zvfh* Vector Half-Precision Floating-Point Extension

Note that half-precision vector floating-point is part of the Zvfh and Zvfhmin extensions, not the base V extension.  Nevertheless, all of these tests are in the same directory structure, under Vf16. Zvfh uses Vf16 <<t-Vf-coverpoints>> to exercise all floating-point instructions with SEW=16.  Zvfhmin only exercises the widening and narrowing conversions:

* vfwcvt.f.f.v

* vfncvt.f.f.w

=== Zvb* Vector Bit Manipulation Extension

Vector bit manipulation extensions include Zvbb and Zvbc.

==== Zvbb Vector Basic Bit Manipulation Extension

[[t-Zvbb-coverpoints]]
.Zvbb Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zvbb.csv[]
,===

==== Zvbc Vector Caryless Multiplication Extension

[[t-Zvbc-coverpoints]]
.Zvbc Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zvbc.csv[]
,===

=== Zvk* Vector Cryptography Extension

There are several Zvk* vector cryptography extensions.  Zvks ShangMi extensions are not yet supported.

==== Zvkb Vector Crypto Bit Manipulation Extension

[[t-Zvkb-coverpoints]]
.Zvkb Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zvkb.csv[]
,===

==== Zvkg Vector Crypto Galois Field Extension

[[t-Zvkg-coverpoints]]
.Zvkg Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zvkg.csv[]
,===


==== Zvkned Vector NIST Encryption and Decryption

[[t-Zvkned-coverpoints]]
.Zvkned Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zvkned.csv[]
,===


==== Zvknh{a/b} Vector NIST Hashing

<<t-Zvknh-coverpoints>> lists the vector hashing instructions.  These apply to both Zknha and Zknhb.

[[t-Zvknh-coverpoints]]
.Zvknh Instruction Coverpoints
[options=header]
[%AUTOWIDTH]
,===
include::../../testplans/Zvknh.csv[]
,===

== Privileged Test Plan

Privileged https://drive.google.com/drive/folders/11hTR2Yl48kOMODxhwrSsC-eXYtM_rJJE?usp=share_link:[test plan spreadsheets] are available.  They need to be edited into a more standarized format. Each test plan spreadsheet contains multiple columns for the applicable configurations.  For example, ZicsrM applies to any configuration with machine mode, ZicsrS applies to any configuration with supervisor mode, and ZicsrF applies to any configuration with floating-point.

[[t-I-priv-normative-statements]]
.I Privileged Normative Statements
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Statement|Coverpoints
|2.2|The base ISA has IALIGN=32, meaning that instructions must
be aligned on a four-byte boundary in memory. An instruction-address-misaligned exception is
generated on a taken branch or unconditional jump if the target address is not IALIGN-bit aligned. This
exception is reported on the branch or jump instruction, not on the target instruction.|
|2.2|No instruction-address-misaligned exception is generated for a conditional branch that is not taken.|
|2.5|If an instruction access-fault or instruction page-fault exception
occurs on the target of a jump or taken branch, the exception is
reported on the target instruction, not on the jump or branch
instruction.|
|2.5.1|The JAL and JALR instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to a four-byte boundary.|
|2.5.2|The conditional branch instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to a four-byte boundary and the branch condition evaluates to
true.|
|2.5.2|If the branch condition evaluates to false, the
instruction-address-misaligned exception will not be raised.|
|2.5.2|Loads with a destination of
`x0` must still raise any exceptions and cause any other side effects
even though the load value is discarded.|
|2.5.2|The EEI will define whether the memory system is little-endian or
big-endian. In RISC-V, endianness is byte-address invariant.|
|2.6|Loads
and stores whose effective address is not naturally aligned to the
referenced datatype (i.e., the effective address is not divisible by the
size of the access in bytes) have behavior dependent on the EEI.| *** more in 2.6 spec
|2.8|The `ECALL` instruction is used to make a service request to the execution
environment.|
|2.8|The `EBREAK` instruction is used to return control to a debugging
environment.|
|===

=== Privileged Instructions

The privileged testplan is organized by major categories of behaviors or extensions.

* Zicsr
* Exceptions
* Interrupts
* Zicntr
* Endian
* Ssstrict
* Svinval
* PMP
* Virtual Memory
* *** CBO

Each of these categories has multiple coverage files with suffixes indicating the circumstances to which they apply.  For example, InterruptsM applies to any configuration with Zicsr and M-mode.  InterruptsU applies to any configuration with Zicsr and U-mode.  InterruptsS applies to any configuration with Zicsr and S-mode.  S-mode implies the presence of U and M modes so all three coverage files apply to a system with S-mode.  Moreover, InterruptsS includes tests that execute in U and M-mode, such as setting a bit in mideleg and then checking that the corresponding interrupt is delegated to S-mode when taken in U-mode, but not when taken in M-mode.

=== Zicsr

Zicsr privileged tests access to CSRs that are mandatory in each privilege mode.
It also tests mandatory privileged instructions: `ecall`, `ebreak`, `mret`, and `sret`.
The CSR read/write/set/clear instructions themselves are tested in the
unprivileged Zicsr tests of <<Zicsr Control/Status Register Instructions>>.

`wfi` is tested in <<Interrupts>> and `sfence.vma` is tested in <<Sv* Virtual Memory>>.

Zicsr does not test reserved or custom instructions or CSRs because their behavior is Unspecified.
Reserved instructions and CSRs are tested in the <<Ssstrict>> Ssstrict tests,
where they should throw an Illegal Instruction exception if not implemented.

==== ZicsrM

*** find all WPRI and WLRL fields.  Don't look at WPRI results.  Only test legal values of WLRL.
==== ZicsrS

==== ZicsrU

==== ZicsrF

==== ZicsrV

==== ZicsrUF

==== ZicsrUV


   TODO check WARL, WLRL, WPRI behaviors

=== Exceptions

==== ExceptionsM

==== ExceptionsS

==== ExceptionsU

==== ExceptionsF

==== ExceptionsV

==== ExceptionsZalrsc

==== ExceptionsZaammo

==== ExceptionsZc

==== ExceptionsZicboS

==== ExceptionsZicboU

==== ExceptionsVM

==== ExceptionsVMZalrsc

==== ExceptionsVMZaamo

=== Interrupts

==== InterruptsM

==== InterruptsS

==== InterruptsU

==== InterruptsSstc

=== Zicntr

counters and hpms

==== ZicntrM

==== ZicntrS

==== ZicntrU

=== Endian

==== EndianM

==== EndianS

==== EndianU

==== EndianZaamo

==== EndianZalrsc

=== Ssstrict

The Ssstrict extension indicates that reserved instructions throw an illegal instruction exception, delegated to supervisor mode.

==== SsstrictS

==== SsstrictV

*** get rid of SsstrictM


=== Svinval

=== PMP

==== PMPM

==== PMPS

==== PMPU

==== PMPZca

==== PMPZicbo

==== PMPZaamo

==== PMPZalrsc

=== Sv* Virtual Memory

==== RV32VM

==== RV32VM_PMP

==== RV64VM

==== RV64VM_PMP

=== CBO

*** why RV64CBO?

==== RV64CBO_VM

==== RV64CBO_PMP

=== H Hypervisor

The Hypervisor Extension adds an H coverage file containing new Hypervisor instructions, and additional coverage files related to exceptions, interrupts, endian, and virtual memory.

[[t-H-normative-statements]]
.Hypervisor Normative Statements
[cols="1, 4, 2" options=header]
|===
|Priv Section|Normative Statement|Coverpoints
|21|CSR `mtval` must not be read-only zero|ZicsrH/mcsr/cp_mtvala
|21|RISC-V harts that implement the
hypervisor extension are encouraged not to hardwire `misa`[7], so that
the extension may be disabled.|Untestable
|21.1|VS-mode interrupts are globally disabled when executing in
U-mode.|InterruptsH/cp_vsint_disabled_u
|21.2|Additional CSRs are provided to HS-mode, but not to VS-mode,
to manage two-stage address translation and to control the behavior of a
VS-mode guest: `hstatus`, `hedeleg`, `hideleg`, `hvip`, `hip`, `hie`,
`hgeip`, `hgeie`, `henvcfg`, `henvcfgh`, `hcounteren`, `htimedelta`,
`htimedeltah`, `htval`, `htinst`, and `hgatp`.|ZicsrH/hcsr/cp_hcsr_access, vscsr/cp_hcsr_inaccessible
|21.2|When V=1, the VS CSRs substitute for the corresponding supervisor CSRs,
taking over all functions of the usual supervisor CSRs except as
specified otherwise. |See each VS CSR
|21.2|When V=1, ... Instructions that normally read or modify a
supervisor CSR shall instead access the corresponding VS CSR.|ZicsrH/vscsr/cp_replica
|21.2|When V=1,
an attempt to read or write a VS CSR directly by its own separate CSR
address causes a virtual-instruction exception.|ZicsrH/vscsr/cp_hcsr_virtualinstructionfault, vucsr/cp_scsr
|21.2|Attempts [to read or write a VS CSR] from U-mode
cause an illegal-instruction exception as usual.|ZicsrH/ucsr/cp_hcsr_inaccessible
|21.2|The VS CSRs can be
accessed as themselves only from M-mode or HS-mode.|Zicsr/mcsr/cp_hcsr_access, hcsr/cp_hcsr_access, vscsr/cp_hcsr_virtualinstructionfault, cp_scsr
|21.2|While V=1, the normal HS-level supervisor CSRs that are replaced by VS
CSRs retain their values but do not affect the behavior of the machine
unless specifically documented to do so.|ZicsrH/vscsr/cp_replica
|21.2|Conversely, when V=0, the VS
CSRs do not ordinarily affect the behavior of the machine other than
being readable and writable by CSR instructions.|Zicsr/hcsr/cp_replica, *** show no other effects
|21.2|Some standard supervisor CSRs (`senvcfg`, `scounteren`, and `scontext`,
possibly others) have no matching VS CSR. These supervisor CSRs continue
to have their usual function and accessibility even when V=1|Zicsr/vscsr/cp_nonreplica
|21.2|In this chapter, we use the term _HSXLEN_ to refer to the effective XLEN
when executing in HS-mode, and _VSXLEN_ to refer to the effective XLEN
when executing in VS-mode.|XLEN not tested
|21.2.1|The VSXL field controls the effective XLEN for VS-mode (known as
VSXLEN), which may differ from the XLEN for HS-mode (HSXLEN).|XLEN not tested
|21.2.1|When VTSR=1, an attempt in VS-mode to execute SRET raises a
virtual-instruction exception.|ExceptionsH/cp_virtual_instruction_vs
|21.2.1|When VTW=1 (and assuming `mstatus`.TW=0),
an attempt in VS-mode to execute WFI raises a virtual-instruction
exception if the WFI does not complete within an
implementation-specific, bounded time limit.|ExceptionsH/cp_virtual_instruction_vs
|21.2.1|When VTVM=1, an attempt in
VS-mode to execute SFENCE.VMA or SINVAL.VMA or to access CSR `satp`
raises a virtual-instruction exception.|ExceptionsH/cp_virtual_instruction_vs
|21.2.1|The VGEIN (Virtual Guest External Interrupt Number) field selects a
guest external interrupt source for VS-level external interrupts.|InterruptsH/cp_trigger_vsei_hgeip
|21.2.1|VGEIN
is a *WLRL* field that must be able to hold values between zero and the
maximum guest external interrupt number (known as GEILEN), inclusive.
|Zicsr/hcsr/cp_hstatus_vgein
|21.2.1|When VGEIN=0, no guest external interrupt source is selected for
VS-level external interrupts.|cp_hgeip0
|21.2.1|Field HU (Hypervisor in U-mode) controls whether the virtual-machine
load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode.
When HU=1, these instructions can be executed in U-mode the same as in
HS-mode. When HU=0, all hypervisor instructions cause an
illegal-instruction exception in U-mode.|ZicsrH/uprivinst/cp_hinst
|21.2.1|The SPV bit (Supervisor Previous Virtualization mode) is written by the
implementation whenever a trap is taken into HS-mode. Just as the SPP
bit in `sstatus` is set to the (nominal) privilege mode at the time of
the trap, the SPV bit in `hstatus` is set to the value of the
virtualization mode V at the time of the trap. |ExceptionsH/cp_ecall_to_hs, cp_hedeleg, InterruptsH/cp_trigger_vs{e/t/s}i, InteruptsS/cp_trigger_*
|21.2.1|When an SRET instruction
is executed when V=0, V is set to SPV.|ZicsrH/mprivinst/cp_sret, ZicsrH/hprivinst/cp_sret
|21.2.1|When V=1 and a trap is taken into HS-mode, bit SPVP (Supervisor Previous
Virtual Privilege) is set to the nominal privilege mode at the time of
the trap, the same as `sstatus`.SPP.|ExeceptionsH/cp_hedeleg, ExceptionsH/cp_ecall_to_hs
|21.2.1|But if V=0 before a trap, SPVP is
left unchanged on trap entry. |ExeceptionsH/cp_hedeleg, ExceptionsH/cp_ecall_to_hs
|21.2.1|SPVP controls the effective privilege of
explicit memory accesses made by the virtual-machine load/store
instructions, HLV, HLVX, and HSV.|H/h*v tests***
|21.2.1|Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into HS-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to `stval`, GVA is set to 1. For any other trap
into HS-mode, GVA is set to 0.|ExceptionsH/cp_hedeleg, ***virtmemtets
|21.2.1|The VSBE bit is a *WARL* field that controls the endianness of explicit memory
accesses made from VS-mode. If VSBE=0, explicit load and store memory
accesses made from VS-mode are little-endian, and if VSBE=1, they are
big-endian.|EndianH/cp_cp_hstatus_vsbe_endianness
|21.2.1|VSBE also controls the endianness of all implicit accesses
to VS-level memory management data structures, such as page tables.|***virtmem endian; check this is adequately tested by VM/ms.5 about mstatus.SBE
|21.2.2|Register `hedeleg` is a 64-bit read/write register|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|Register `hideleg` is an HSXLEN-bit read/write register|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|A synchronous trap that has been delegated to HS-mode (using `medeleg`)
is further delegated to VS-mode if V=1 before the trap and the
corresponding `hedeleg` bit is set.|ExceptionsH/cp_hedeleg
|21.2.2|Each bit of `hedeleg` shall be
either writable or read-only zero. Many bits of `hedeleg` are required
specifically to be writable or zero|ZicsrH/mcsr/cp_hcsr_access
|21.2.2|Bit 0, corresponding to
instruction address-misaligned exceptions, must be writable if
IALIGN=32.|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|When XLEN=32, `hedelegh` is a 32-bit read/write register
that aliases bits 63:32 of `hedeleg`.|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|Register `hedelegh` does not exist when XLEN=64.|ZicsrH/mcsr/cp_illegalupper
|21.2.2|An interrupt that has been delegated to HS-mode (using `mideleg`) is
further delegated to VS-mode if the corresponding `hideleg` bit is set.|InterruptsH/cp_priority_deleg_vsi
|21.2.2|Among bits 15:0 of `hideleg`, bits 10, 6, and 2 (corresponding to the
standard VS-level interrupts) are writable, and bits 12, 9, 5, and 1
(corresponding to the standard S-level interrupts) are read-only zeros.|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|When a virtual supervisor external interrupt (code 10) is delegated to
VS-mode, it is automatically translated by the machine into a supervisor
external interrupt (code 9) for VS-mode, including the value written to
`vscause` on an interrupt trap. Likewise, a virtual supervisor timer
interrupt (6) is translated into a supervisor timer interrupt (5) for
VS-mode, and a virtual supervisor software interrupt (2) is translated
into a supervisor software interrupt (1) for VS-mode.|cp_hideleg_hip_vs, cp_hideleg_hip_vu

*** following entries need coverpoints

|21.2.3|Register `hvip` is an HSXLEN-bit read/write register that a hypervisor
can write to indicate virtual interrupts intended for VS-mode. Bits of
`hvip` that are not writable are read-only zeros.|
|21.2.3|Bits VSEIP, VSTIP,
and VSSIP of `hvip` are writable.|
|21.2.3|Setting VSEIP=1 in `hvip` asserts a
VS-level external interrupt; setting VSTIP asserts a VS-level timer
interrupt; and setting VSSIP asserts a VS-level software interrupt.|
|21.2.3|Registers `hip` and `hie` are HSXLEN-bit read/write registers|
|21.2.3|For each writable bit in `sie`, the corresponding bit shall be read-only
zero in both `hip` and `hie`. Hence, the nonzero bits in `sie` and `hie`
are always mutually exclusive, and likewise for `sip` and `hip`.|
|21.2.3|An interrupt _i_ will trap to HS-mode whenever all of the following are
true: (a) either the current operating mode is HS-mode and the SIE bit
in the `sstatus` register is set, or the current operating mode has less
privilege than HS-mode; (b) bit _i_ is set in both `sip` and `sie`, or
in both `hip` and `hie`; and (c) bit _i_ is not set in `hideleg`.|
|21.2.3|If bit _i_ of `sie` is read-only zero, the same bit in register `hip`
may be writable or may be read-only. When bit _i_ in `hip` is writable,
a pending interrupt _i_ can be cleared by writing 0 to this bit. If
interrupt _i_ can become pending in `hip` but bit _i_ in `hip` is
read-only, then either the interrupt can be cleared by clearing bit _i_
of `hvip`, or the implementation must provide some other mechanism for
clearing the pending interrupt (which may involve a call to the
execution environment).|
|21.2.3|A bit in `hie` shall be writable if the corresponding interrupt can ever
become pending in `hip`. Bits of `hie` that are not writable shall be
read-only zero.|
|21.2.3|Bits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and
interrupt-enable bits for guest external interrupts at supervisor level
(HS-level). SGEIP is read-only in `hip`, and is 1 if and only if the
bitwise logical-AND of CSRs `hgeip` and `hgeie` is nonzero in any bit.|
|21.2.3|Bits `hip`.VSEIP and `hie`.VSEIE are the interrupt-pending and
interrupt-enable bits for VS-level external interrupts. VSEIP is
read-only in `hip`, and is the logical-OR of these interrupt sources:

* bit VSEIP of `hvip`;
* the bit of `hgeip` selected by `hstatus`.VGEIN; and
* any other platform-specific external interrupt signal directed to
VS-level.|
|21.2.3|Bits `hip`.VSTIP and `hie`.VSTIE are the interrupt-pending and
interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only
in `hip`, and is the logical-OR of `hvip`.VSTIP and any other
platform-specific timer interrupt signal directed to VS-level.|
|21.2.3|Bits `hip`.VSSIP and `hie`.VSSIE are the interrupt-pending and
interrupt-enable bits for VS-level software interrupts. VSSIP in `hip`
is an alias (writable) of the same bit in `hvip`.|
|21.2.3|Multiple simultaneous interrupts destined for HS-mode are handled in the
following decreasing priority order: SEI, SSI, STI, SGEI, VSEI, VSSI,
VSTI, LCOFI.|
|21.2.4|The `hgeip` register is an HSXLEN-bit read-only register, formatted as
shown in <<hgeipreg>>, that indicates pending guest
external interrupts for this hart. The `hgeie` register is an HSXLEN-bit
read/write register, formatted as shown in
<<hgeiereg>>, that contains enable bits for the
guest external interrupts at this hart. Guest external interrupt number
_i_ corresponds with bit _i_ in both `hgeip` and `hgeie`.|
|21.2.4|The number of bits implemented in `hgeip` and `hgeie` for guest external
interrupts is UNSPECIFIED and may be zero. This number is known as _GEILEN_. The
least-significant bits are implemented first, apart from bit 0. Hence,
if GEILEN is nonzero, bits GEILEN:1 shall be writable in `hgeie`, and
all other bit positions shall be read-only zeros in both `hgeip` and
`hgeie`.|
|21.2.4|Register `hgeie` selects the subset of guest external interrupts that
cause a supervisor-level (HS-level) guest external interrupt. The enable
bits in `hgeie` do not affect the VS-level external interrupt signal
selected from `hgeip` by `hstatus`.VGEIN.|
|21.2.5|The `henvcfg` CSR is a 64-bit read/write register, formatted
as shown in <<henvcfg>>, that controls
certain characteristics of the execution environment when virtualization
mode V=1.|
|21.2.5|If bit FIOM (Fence of I/O implies Memory) is set to one in `henvcfg`,
FENCE instructions executed when V=1 are modified so the requirement to
order accesses to device I/O implies also the requirement to order main
memory accesses. <<henvcfg-FIOM>> details the modified
interpretation of FENCE instruction bits PI, PO, SI, and SO when FIOM=1
and V=1.|
|21.2.5|Similarly, when FIOM=1 and V=1, if an atomic instruction that accesses a
region ordered as device I/O has its _aq_ and/or _rl_ bit set, then that
instruction is ordered as though it accesses both device I/O and memory.|
|21.2.5|The PBMTE bit controls whether the Svpbmt extension is available for use
in VS-stage address translation. When PBMTE=1, Svpbmt is available for
VS-stage address translation. When PBMTE=0, the implementation behaves
as though Svpbmt were not implemented for VS-stage address translation.
If Svpbmt is not implemented, PBMTE is read-only zero.|
|21.2.5|If the Svadu extension is implemented, the ADUE bit controls whether hardware
updating of PTE A/D bits is enabled for VS-stage address translation.
When ADUE=1, hardware updating of PTE A/D bits is enabled during VS-stage
address translation, and the implementation behaves as though the Svade
extension were not implemented for VS-mode address translation.
When ADUE=0, the implementation behaves as though Svade were implemented for
VS-stage address translation.
If Svadu is not implemented, ADUE is read-only zero.|
|21.2.5|The definition of the STCE field is furnished by the Sstc extension.|
|21.2.5|The definition of the CBZE field is furnished by the Zicboz extension.|
|21.2.5|The definitions of the CBCFE and CBIE fields are furnished by the Zicbom extension.|
|21.2.5|The definition of the PMM field is furnished by the Ssnpm extension.|
|21.2.5|The Zicfilp extension adds the `LPE` field in `henvcfg`. When the `LPE` field
is set to 1, the Zicfilp extension is enabled in VS-mode. When the `LPE` field
is 0, the Zicfilp extension is not enabled in VS-mode and the following rules
apply to VS-mode:

* The hart does not update the `ELP` state; it remains as `NO_LP_EXPECTED`.
* The `LPAD` instruction operates as a no-op.|

|21.2.5|The Zicfiss extension adds the `SSE` field in `henvcfg`. If the `SSE` field is
set to 1, the Zicfiss extension is activated in VS-mode. When the `SSE` field is
0, the Zicfiss extension remains inactive in VS-mode, and the following rules
apply when `V=1`:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.
* The `pte.xwr=010b` encoding in VS-stage page tables becomes reserved.
* The `senvcfg.SSE` field will read as zero and is read-only.
* When `menvcfg.SSE` is one, `SSAMOSWAP.W/D` raises a virtual-instruction
  exception.|
|21.2.5|The Ssdbltrp extension adds the double-trap-enable (`DTE`) field in `henvcfg`.
When `henvcfg.DTE` is zero, the implementation behaves as though Ssdbltrp is not
implemented for VS-mode and the `vsstatus.SDT` bit is read-only zero.|
|21.2.5|When XLEN=32, `henvcfgh` is a
32-bit read/write register that aliases bits 63:32
of `henvcfg`. Register `henvcfgh` does not exist when
XLEN=64.|
|21.2.6|The counter-enable register `hcounteren` is a 32-bit register that
controls the availability of the hardware performance monitoring
counters to the guest virtual machine.|
|21.2.6|When the CY, TM, IR, or HPM_n_ bit in the `hcounteren` register is
clear, attempts to read the `cycle`, `time`, `instret`, or
`hpmcounter` _n_ register while V=1 will cause a virtual-instruction
exception if the same bit in `mcounteren` is 1. When one of these bits
is set, access to the corresponding register is permitted when V=1,
unless prevented for some other reason. In VU-mode, a counter is not
readable unless the applicable bits are set in both `hcounteren` and
`scounteren`.|
|21.2.6|`hcounteren` must be implemented. However, any of the bits may be
read-only zero, indicating reads to the corresponding counter will cause
an exception when V=1. Hence, they are effectively *WARL* fields.|
|21.2.7|The `htimedelta` CSR is a 64-bit read/write register that contains the delta
between the value of the `time` CSR and the value returned in VS-mode or
VU-mode. That is, reading the `time` CSR in VS or VU mode returns the
sum of the contents of `htimedelta` and the actual value of `time`.|
|21.2.7|When XLEN=32, `htimedeltah` is a 32-bit read/write register
that aliases bits 63:32 of `htimedelta`.
Register `htimedeltah` does not exist when XLEN=64.|
|21.2.7|If the `time` CSR is implemented, `htimedelta` (and `htimedeltah` for XLEN=32)
must be implemented.|
|21.2.8|The `htval` register is an HSXLEN-bit read/write register formatted as
shown in <<htvalreg>>. When a trap is taken into
HS-mode, `htval` is written with additional exception-specific
information, alongside `stval`, to assist software in handling the trap.|
|21.2.8|When a guest-page-fault trap is taken into HS-mode, `htval` is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, `htval` is set to zero, but a future
standard or extension may redefine `htval's` setting for other traps.|
|21.2.8|A guest-page fault may arise due to an implicit memory access during
first-stage (VS-stage) address translation, in which case a guest
physical address written to `htval` is that of the implicit memory
access that faulted—for example, the address of a VS-level page table
entry that could not be read. (The guest physical address corresponding
to the original virtual address is unknown when VS-stage translation
fails to complete.) Additional information is provided in CSR `htinst`
to disambiguate such situations.|
|21.2.8|Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in `htval` corresponds to the faulting
portion of the access as indicated by the virtual address in `stval`.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero `htval` corresponds to the faulting portion of
the instruction as indicated by the virtual address in `stval`.|
|21.2.8|`htval` is a *WARL* register that must be able to hold zero and may be capable
of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.|
|21.2.9|The `htinst` register is an HSXLEN-bit read/write register formatted as
shown in <<htinstreg>>. When a trap is taken into
HS-mode, `htinst` is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to `htinst` on a trap
are documented in <<tinst-vals>>.|
|21.2.9|`htinst` is a *WARL* register that need only be able to hold the values that
the implementation may automatically write to it on a trap.|
|21.2.10|The `hgatp` register is an HSXLEN-bit read/write register, formatted as
shown in <<rv32hgatp>> for HSXLEN=32 and
<<rv64hgatp>> for HSXLEN=64, which controls
G-stage address translation and protection, the second stage of
two-stage translation for guest virtual addresses (see
<<two-stage-translation>>). Similar to CSR `satp`, this
register holds the physical page number (PPN) of the guest-physical root
page table; a virtual machine identifier (VMID), which facilitates
address-translation fences on a per-virtual-machine basis; and the MODE
field, which selects the address-translation scheme for guest physical
addresses. When `mstatus`.TVM=1, attempts to read or write `hgatp` while
executing in HS-mode will raise an illegal-instruction exception.|
|21.2.10|<<hgatp-mode>> shows the encodings of the MODE field when
HSXLEN=32 and HSXLEN=64. When MODE=Bare, guest physical addresses are
equal to supervisor physical addresses, and there is no further memory
protection for a guest virtual machine beyond the physical memory
protection scheme described in <<pmp>>. In this
case, software must write zero to the remaining fields in `hgatp`.
Attempting to select MODE=Bare with a nonzero pattern in the remaining fields
has an UNSPECIFIED effect on the value that the remaining fields assume and an
UNSPECIFIED effect on G-stage address translation and protection behavior.|
|21.2.10|When HSXLEN=32, the only other valid setting for MODE is Sv32x4, which
is a modification of the usual Sv32 paged virtual-memory scheme,
extended to support 34-bit guest physical addresses.| 
|21.2.10|When HSXLEN=64,
modes Sv39x4, Sv48x4, and Sv57x4 are defined as modifications of the
Sv39, Sv48, and Sv57 paged virtual-memory schemes. All of these paged
virtual-memory schemes are described in
<<guest-addr-translation>>.|
|21.2.10|The remaining MODE settings when HSXLEN=64 are reserved for future use
and may define different interpretations of the other fields in `hgatp`.|
|21.2.10|Implementations are not required to support all defined MODE settings
when HSXLEN=64|.
|21.2.10|A write to `hgatp` with an unsupported MODE value is not ignored as it
is for `satp`. Instead, the fields of `hgatp` are *WARL* in the normal way,
when so indicated.|
|21.2.10|As explained in <<guest-addr-translation>>, for the
paged virtual-memory schemes (Sv32x4, Sv39x4, Sv48x4, and Sv57x4), the
root page table is 16 KiB and must be aligned to a 16-KiB boundary. In
these modes, the lowest two bits of the physical page number (PPN) in
`hgatp` always read as zeros. An implementation that supports only the
defined paged virtual-memory schemes and/or Bare may make PPN[1:0]
read-only zero.|
|21.2.10|The number of VMID bits is UNSPECIFIED and may be zero. The number of implemented
VMID bits, termed _VMIDLEN_, may be determined by writing one to every
bit position in the VMID field, then reading back the value in `hgatp`
to see which bit positions in the VMID field hold a one. The
least-significant bits of VMID are implemented first: that is, if
VMIDLEN > 0, VMID[VMIDLEN-1:0] is writable. The maximal
value of VMIDLEN, termed VMIDMAX, is 7 for Sv32x4 or 14 for Sv39x4,
Sv48x4, and Sv57x4.|
|21.2.10|The `hgatp` register is considered _active_ for the purposes of the
address-translation algorithm _unless_ the effective privilege mode is U
and `hstatus`.HU=0.|
|21.2.11|The `vsstatus` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sstatus`, formatted as shown
in <<vsstatusreg-rv32>> when VSXLEN=32 and
<<vsstatusreg>> when VSXLEN=64. When V=1,
`vsstatus` substitutes for the usual `sstatus`, so instructions that
normally read or modify `sstatus` actually access `vsstatus` instead.|
|21.2.11|The UXL field controls the effective XLEN for VU-mode, which may differ
from the XLEN for VS-mode (VSXLEN). When VSXLEN=32, the UXL field does
not exist, and VU-mode XLEN=32. When VSXLEN=64, UXL is a *WARL* field that is
encoded the same as the MXL field of `misa`, shown in <<misabase>>. In particular, an implementation may make UXL be a read-only copy of field VSXL of `hstatus`, forcing VU-mode XLEN=VSXLEN.|
|21.2.11|If VSXLEN is changed from 32 to a wider width, and if field UXL is not
restricted to a single value, it gets the value corresponding to the
widest supported width not wider than the new VSXLEN.|
|21.2.11|When V=1, both `vsstatus`.FS and the HS-level `sstatus`.FS are in
effect. Attempts to execute a floating-point instruction when either
field is 0 (Off) raise an illegal-instruction exception. Modifying the
floating-point state when V=1 causes both fields to be set to 3 (Dirty).|
|21.2.11|Similarly, when V=1, both `vsstatus`.VS and the HS-level `sstatus`.VS
are in effect. Attempts to execute a vector instruction when either
field is 0 (Off) raise an illegal-instruction exception. Modifying the
vector state when V=1 causes both fields to be set to 3 (Dirty).|
|21.2.11|Read-only fields SD and XS summarize the extension context status as it
is visible to VS-mode only. For example, the value of the HS-level
`sstatus`.FS does not affect `vsstatus`.SD.|
|21.2.11|An implementation may make field UBE be a read-only copy of
`hstatus`.VSBE.|
|21.2.11|When V=0, `vsstatus` does not directly affect the behavior of the
machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the
MPRV feature in the `mstatus` register is used to execute a load or
store _as though_ V=1.|
|21.2.11|The Zicfilp extension adds the `SPELP` field that holds the previous `ELP`, and
is updated as specified in <<ZICFILP_FORWARD_TRAPS>>. The `SPELP` field is
encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.
|

|21.2.11|The Ssdbltrp adds an S-mode-disable-trap (`SDT`) field extension to address
double trap (See <<supv-double-trap>>) in VS-mode.|
|21.2.12|The `vsip` and `vsie` registers are VSXLEN-bit read/write registers that
are VS-mode’s versions of supervisor CSRs `sip` and `sie`, formatted as
shown in <<vsipreg>> and <<vsiereg>>
respectively. When V=1, `vsip` and `vsie` substitute for the usual `sip`
and `sie`, so instructions that normally read or modify `sip`/`sie`
actually access `vsip`/`vsie` instead. However, interrupts directed to
HS-level continue to be indicated in the HS-level `sip` register, not in
`vsip`, when V=1.|
|21.2.12|Extension Shlcofideleg supports delegating LCOFI interrupts to VS-mode.
If the Shlcofideleg extension is implemented, `hideleg` bit 13 is
writable; otherwise, it is read-only zero.
When bit 13 of `hideleg` is zero, `vsip`.LCOFIP and `vsie`.LCOFIE
are read-only zeros.
Else, `vsip`.LCOFIP and `vsie`.LCOFIE are aliases of `sip`.LCOFIP
and `sie`.LCOFIE.|
|21.2.12|When bit 10 of `hideleg` is zero, `vsip`.SEIP and `vsie`.SEIE are
read-only zeros. Else, `vsip`.SEIP and `vsie`.SEIE are aliases of
`hip`.VSEIP and `hie`.VSEIE.|
|21.2.12|When bit 6 of `hideleg` is zero, `vsip`.STIP and `vsie`.STIE are
read-only zeros. Else, `vsip`.STIP and `vsie`.STIE are aliases of
`hip`.VSTIP and `hie`.VSTIE.|
|21.2.12|When bit 2 of `hideleg` is zero, `vsip`.SSIP and `vsie`.SSIE are
read-only zeros. Else, `vsip`.SSIP and `vsie`.SSIE are aliases of
`hip`.VSSIP and `hie`.VSSIE.|
|21.2.13|The `vstvec` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `stvec`, formatted as shown in
<<vstvecreg>>. When V=1, `vstvec` substitutes for
the usual `stvec`, so instructions that normally read or modify `stvec`
actually access `vstvec` instead. When V=0, `vstvec` does not directly
affect the behavior of the machine.|
|21.2.14|The `vsscratch` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sscratch`, formatted as shown
in <<vsscratchreg>>. When V=1, `vsscratch`
substitutes for the usual `sscratch`, so instructions that normally read
or modify `sscratch` actually access `vsscratch` instead. The contents
of `vsscratch` never directly affect the behavior of the machine.|
|21.2.15|The `vsepc` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sepc`, formatted as shown in
<<vsepcreg>>. When V=1, `vsepc` substitutes for the
usual `sepc`, so instructions that normally read or modify `sepc`
actually access `vsepc` instead. When V=0, `vsepc` does not directly
affect the behavior of the machine.|
|21.2.15|`vsepc` is a *WARL* register that must be able to hold the same set of values
that `sepc` can hold.|
|21.2.16|The `vscause` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `scause`, formatted as shown in
<<vscausereg>>. When V=1, `vscause` substitutes
for the usual `scause`, so instructions that normally read or modify
`scause` actually access `vscause` instead. When V=0, `vscause` does not
directly affect the behavior of the machine.|
|21.2.16|`vscause` is a *WLRL* register that must be able to hold the same set of
values that `scause` can hold.|
|21.2.17|The `vstval` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `stval`, formatted as shown in
<<vstvalreg>>. When V=1, `vstval` substitutes for
the usual `stval`, so instructions that normally read or modify `stval`
actually access `vstval` instead. When V=0, `vstval` does not directly
affect the behavior of the machine.|
|21.2.17|`vstval` is a *WARL* register that must be able to hold the same set of values
that `stval` can hold.|
|21.2.18|The `vsatp` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `satp`, formatted as shown in
<<rv32vsatpreg>> for VSXLEN=32 and <<rv64vsatpreg>> for VSXLEN=64. When V=1,
`vsatp` substitutes for the usual `satp`, so instructions that normally
read or modify `satp` actually access `vsatp` instead. `vsatp` controls
VS-stage address translation, the first stage of two-stage translation
for guest virtual addresses (see
<<two-stage-translation>>).|
|21.2.18|The `vsatp` register is considered _active_ for the purposes of the
address-translation algorithm _unless_ the effective privilege mode is U
and `hstatus`.HU=0. However, even when `vsatp` is active, VS-stage
page-table entries’ A bits must not be set as a result of speculative
execution, unless the effective privilege mode is VS or VU.|
|21.2.18|When V=0, a write to `vsatp` with an unsupported MODE value is either
ignored as it is for `satp`, or the fields of `vsatp` are treated as *WARL* in
the normal way. However, when V=1, a write to `satp` with an unsupported
MODE value _is_ ignored and no write to `vsatp` is effected.|
|21.2.18|When V=0, `vsatp` does not directly affect the behavior of the machine,
unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV
feature in the `mstatus` register is used to execute a load or store _as
though_ V=1.|
|21.3.1|
The hypervisor virtual-machine load and store instructions are valid
only in M-mode or HS-mode, or in U-mode when `hstatus`.HU=1. Each
instruction performs an explicit memory access with an effective privilege mode
of VS or VU. The effective privilege mode of the explicit memory access is VU
when `hstatus`.SPVP=0, and VS when `hstatus`.SPVP=1. As usual for VS-mode and
VU-mode, two-stage address translation is applied, and
the HS-level `sstatus`.SUM is ignored. HS-level `sstatus`.MXR makes
execute-only pages readable by explicit loads for both stages of address translation
(VS-stage and G-stage), whereas `vsstatus`.MXR affects only the first
translation stage (VS-stage).|
|21.3.1|For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
and LD, there is a corresponding virtual-machine load instruction:
HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I
or RV64I store instruction, SB, SH, SW, and SD, there is a corresponding
virtual-machine store instruction: HSV.B, HSV.H, HSV.W, and HSV.D.
Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.|
|21.3.1|Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU,
except that _execute_ permission takes the place of _read_ permission
during address translation. That is, the memory being read must be
executable in both stages of address translation, but read permission is
not required. For the supervisor physical address that results from
address translation, the supervisor physical memory attributes must
grant both _execute_ and _read_ permissions. (The _supervisor physical
memory attributes_ are the machine’s physical memory attributes as
modified by physical memory protection, <<pmp>>, for
supervisor level.)|
|21.3.1|HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For
RV32, HLVX.WU can be considered a variant of HLV.W, as sign extension is
irrelevant for 32-bit values.)|
|21.3.1|Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,
or HSV) when V=1 cause a virtual-instruction exception. Attempts to execute
one of these same instructions from U-mode when `hstatus`.HU=0 cause an
illegal-instruction exception.|
|21.3.2|The hypervisor memory-management fence instructions, HFENCE.VVMA and
HFENCE.GVMA, perform a function similar to SFENCE.VMA
(<<sfence.vma>>), except applying to the
VS-level memory-management data structures controlled by CSR `vsatp`
(HFENCE.VVMA) or the guest-physical memory-management data structures
controlled by CSR `hgatp` (HFENCE.GVMA). Instruction SFENCE.VMA applies
only to the memory-management data structures controlled by the current
`satp` (either the HS-level `satp` when V=0 or `vsatp` when V=1).|
|21.3.2|HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the
same as temporarily entering VS-mode and executing SFENCE.VMA. Executing
an HFENCE.VVMA guarantees that any previous stores already visible to
the current hart are ordered before all implicit reads by that hart done
for VS-stage address translation for instructions that

* are subsequent to the HFENCE.VVMA, and
* execute when `hgatp`.VMID has the same setting as it did when
HFENCE.VVMA executed.
|
|21.3.2|Implicit reads need not be ordered when `hgatp`.VMID is different than
at the time HFENCE.VVMA executed. If operand __rs1__≠`x0`, it specifies a single guest virtual address, and if operand __rs2__≠`x0`, it specifies a single guest address-space identifier (ASID).|
|21.3.2|When __rs2__≠`x0`, bits XLEN-1:ASIDMAX of the value held
in _rs2_ are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
ASIDLEN < ASIDMAX, the implementation shall ignore bits
ASIDMAX-1:ASIDLEN of the value held in _rs2_.|
|21.3.2|Neither `mstatus`.TVM nor `hstatus`.VTVM causes HFENCE.VVMA to trap.|
|21.3.2|HFENCE.GVMA is valid only in HS-mode when `mstatus`.TVM=0, or in M-mode
(irrespective of `mstatus`.TVM). Executing an HFENCE.GVMA instruction
guarantees that any previous stores already visible to the current hart
are ordered before all implicit reads by that hart done for G-stage
address translation for instructions that follow the HFENCE.GVMA. If
operand __rs1__≠`x0`, it specifies a single guest
physical address, shifted right by 2 bits, and if operand
__rs2__≠`x0`, it specifies a single virtual machine
identifier (VMID).|
|21.3.2|When __rs2__≠`x0`, bits XLEN-1:VMIDMAX of the value held
in _rs2_ are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
VMIDLEN < VMIDMAX, the implementation shall ignore bits
VMIDMAX-1:VMIDLEN of the value held in _rs2_|
|21.3.2|If `hgatp`.MODE is changed for a given VMID, an HFENCE.GVMA with
_rs1_=`x0` (and _rs2_ set to either `x0` or the VMID) must be executed
to order subsequent guest translations with the MODE change—even if the
old MODE or new MODE is Bare.|
|21.3.2|Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a
virtual-instruction exception, while attempts to do the same in U-mode cause an
illegal-instruction exception. Attempting to execute HFENCE.GVMA in HS-mode
when `mstatus`.TVM=1 also causes an illegal-instruction exception.|
|21.4.1|The hypervisor extension adds two fields, MPV and GVA, to the
machine-level `mstatus` or `mstatush` CSR, and modifies the behavior of
several existing `mstatus` fields.
<<hypervisor-mstatus>> shows the modified
`mstatus` register when the hypervisor extension is implemented and
MXLEN=64. When MXLEN=32, the hypervisor extension adds MPV and GVA not
to `mstatus` but to `mstatush`.
<<hypervisor-mstatush>> shows the
`mstatush` register when the hypervisor extension is implemented and
MXLEN=32.|
|21.4.1|The MPV bit (Machine Previous Virtualization Mode) is written by the
implementation whenever a trap is taken into M-mode. Just as the MPP
field is set to the (nominal) privilege mode at the time of the trap,
the MPV bit is set to the value of the virtualization mode V at the time
of the trap. When an MRET instruction is executed, the virtualization
mode V is set to MPV, unless MPP=3, in which case V remains 0.|
|21.4.1|Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into M-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to `mtval`, GVA is set to 1. For any other trap
into M-mode, GVA is set to 0.|
|21.4.1|The TSR and TVM fields of `mstatus` affect execution only in HS-mode,
not in VS-mode. The TW field affects execution in all modes except
M-mode.|
|21.4.1|Setting TVM=1 prevents HS-mode from accessing `hgatp` or executing
HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to `vsatp` or
instructions HFENCE.VVMA or HINVAL.VVMA.|
|21.4.1|The hypervisor extension changes the behavior of the Modify Privilege
field, MPRV, of `mstatus`. When MPRV=0, translation and protection
behave as normal. When MPRV=1, explicit memory accesses are translated
and protected, and endianness is applied, as though the current
virtualization mode were set to MPV and the current nominal privilege
mode were set to MPP. <<h-mprv>> enumerates the cases.|
|21.4.1|MPRV does not affect the virtual-machine load/store instructions, HLV,
HLVX, and HSV. The explicit loads and stores of these instructions
always act as though V=1 and the nominal privilege mode were
`hstatus`.SPVP, overriding MPRV.|
|21.4.1|The `mstatus` register is a superset of the HS-level `sstatus` register
but is not a superset of `vsstatus`.|
|21.4.2|When the hypervisor extension is implemented, bits 10, 6, and 2 of
`mideleg` (corresponding to the standard VS-level interrupts) are each
read-only one. Furthermore, if any guest external interrupts are
implemented (GEILEN is nonzero), bit 12 of `mideleg` (corresponding to
supervisor-level guest external interrupts) is also read-only one.
VS-level interrupts and guest external interrupts are always delegated
past M-mode to HS-mode.|
|21.4.2|For bits of `mideleg` that are zero, the corresponding bits in
`hideleg`, `hip`, and `hie` are read-only zeros.|
|21.4.3|Bits SGEIP, VSEIP, VSTIP, and VSSIP in `mip` are aliases for the same
bits in hypervisor CSR `hip`, while SGEIE, VSEIE, VSTIE, and VSSIE in
`mie` are aliases for the same bits in `hie`.|
|21.4.4|The `mtval2` register is an MXLEN-bit read/write register formatted as
shown in <<mtval2reg>>. When a trap is taken into
M-mode, `mtval2` is written with additional exception-specific
information, alongside `mtval`, to assist software in handling the trap.|
|21.4.4|When a guest-page-fault trap is taken into M-mode, `mtval2` is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, `mtval2` is set to zero, but a future
standard or extension may redefine `mtval2's` setting for other traps.|
|21.4.4|If a guest-page fault is due to an implicit memory access during
first-stage (VS-stage) address translation, a guest physical address
written to `mtval2` is that of the implicit memory access that faulted.
Additional information is provided in CSR `mtinst` to disambiguate such
situations.|
|21.4.4|Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in `mtval2` corresponds to the faulting
portion of the access as indicated by the virtual address in `mtval`.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero `mtval2` corresponds to the faulting portion of
the instruction as indicated by the virtual address in `mtval`.|
|21.4.4|`mtval2` is a *WARL* register that must be able to hold zero and may be
capable of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.|
|21.4.4|The Ssdbltrap extension (See <<ssdbltrp>>) requires the implementation of
the `mtval2` CSR.|
|21.4.5|The `mtinst` register is an MXLEN-bit read/write register formatted as
shown in <<mtinstreg>>. When a trap is taken into
M-mode, `mtinst` is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to `mtinst` on a trap
are documented in <<tinst-vals>>.|
|21.4.5|`mtinst` is a *WARL* register that need only be able to hold the values that
the implementation may automatically write to it on a trap.|
|22.5|Whenever the current virtualization mode V is 1, two-stage address
translation and protection is in effect. For any virtual memory access,
the original virtual address is converted in the first stage by VS-level
address translation, as controlled by the `vsatp` register, into a
_guest physical address_. The guest physical address is then converted
in the second stage by guest physical address translation, as controlled
by the `hgatp` register, into a supervisor physical address. The two
stages are known also as VS-stage and G-stage translation. Although
there is no option to disable two-stage address translation when V=1,
either stage of translation can be effectively disabled by zeroing the
corresponding `vsatp` or `hgatp` register.|
|22.5|The `vsstatus` field MXR, which makes execute-only pages readable by explicit loads, only
overrides VS-stage page protection. Setting MXR at VS-level does not
override guest-physical page protections. Setting MXR at HS-level,
however, overrides both VS-stage and G-stage execute-only permissions.|
|22.5|When V=1, memory accesses that would normally bypass address translation
are subject to G-stage address translation alone. This includes memory
accesses made in support of VS-stage address translation, such as reads
and writes of VS-level page tables.|
|22.5|Machine-level physical memory protection applies to supervisor physical
addresses and is in effect regardless of virtualization mode.| 
|22.5.1|The mapping of guest physical addresses to supervisor physical addresses
is controlled by CSR `hgatp` (<<hgatp>>).|
|22.5.1|When the address translation scheme selected by the MODE field of
`hgatp` is Bare, guest physical addresses are equal to supervisor
physical addresses without modification, and no memory protection
applies in the trivial translation of guest physical addresses to
supervisor physical addresses.|
|22.5.1|When `hgatp`.MODE specifies a translation scheme of Sv32x4, Sv39x4,
Sv48x4, or Sv57x4, G-stage address translation is a variation on the
usual page-based virtual address translation scheme of Sv32, Sv39, Sv48,
or Sv57, respectively. In each case, the size of the incoming address is
widened by 2 bits (to 34, 41, 50, or 59 bits). To accommodate the
2 extra bits, the root page table (only) is expanded by a factor of four
to be 16 KiB instead of the usual 4 KiB. Matching its larger size, the
root page table also must be aligned to a 16 KiB boundary instead of the
usual 4 KiB page boundary. Except as noted, all other aspects of Sv32,
Sv39, Sv48, or Sv57 are adopted unchanged for G-stage translation.
Non-root page tables and all page table entries (PTEs) have the same
formats as documented in <<sv32>>, <<sv39>>, <<sv48>>, and <<sv57>>.|
|22.5.1|For Sv32x4, an incoming guest physical address is partitioned into a
virtual page number (VPN) and page offset as shown in
<<sv32x4va>>. This partitioning is identical to
that for an Sv32 virtual address as depicted in
<<sv32va>>, except with 2 more bits at the
high end in VPN[1]. (Note that the fields of a partitioned guest
physical address also correspond one-for-one with the structure that
Sv32 assigns to a physical address, depicted in
<<sv32va>>.)|
|22.5.1|For Sv39x4, an incoming guest physical address is partitioned as shown
in <<sv39x4va>>. This partitioning is identical to that for an Sv39 virtual address as depicted in <<sv39va>>, except with 2 more bits at the
high end in VPN[2]. Address bits 63:41 must all be zeros, or else a
guest-page-fault exception occurs.|
|22.5.1|For Sv48x4, an incoming guest physical address is partitioned as shown
in <<sv48x4va>>. This partitioning is identical to
that for an Sv48 virtual address as depicted in
<<sv48va>>, except with 2 more bits at the
high end in VPN[3]. Address bits 63:50 must all be zeros, or else a
guest-page-fault exception occurs.|
|22.5.1|For Sv57x4, an incoming guest physical address is partitioned as shown
in <<sv57x4va>>. This partitioning is identical to
that for an Sv57 virtual address as depicted in
<<sv57va>>, except with 2 more bits at the
high end in VPN[4]. Address bits 63:59 must all be zeros, or else a
guest-page-fault exception occurs.|
|22.5.1|The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical
address is accomplished with the same algorithm used for Sv32, Sv39,
Sv48, or Sv57, as presented in
<<sv32algorithm>>, except that:

* `hgatp` substitutes for the usual `satp`;
* for the translation to begin, the effective privilege mode must be
VS-mode or VU-mode;
* when checking the U bit, the current privilege mode is always taken to
be U-mode; and
* guest-page-fault exceptions are raised instead of regular page-fault
exceptions.|
|22.5.1|For G-stage address translation, all memory accesses (including those
made to access data structures for VS-stage address translation) are
considered to be user-level accesses, as though executed in U-mode.
Access type permissions—readable, writable, or executable—are checked
during G-stage translation the same as for VS-stage translation. For a
memory access made to support VS-stage address translation (such as to
read/write a VS-level page table), permissions and the need to set A
and/or D bits at the G-stage level are checked as though for an implicit
load or store, not for the original access type. However, any exception
is always reported for the original access type (instruction, load, or
store/AMO).|
|22.5.1|The G bit in all G-stage PTEs is currently not used. Until
its use is defined by a standard extension, it should be cleared by
software for forward compatibility, and must be ignored by hardware.|
|22.5.2|Guest-page-fault traps may be delegated from M-mode to HS-mode under the
control of CSR `medeleg`, but cannot be delegated to other privilege
modes. On a guest-page fault, CSR `mtval` or `stval` is written with the
faulting guest virtual address as usual, and `mtval2` or `htval` is
written either with zero or with the faulting guest physical address,
shifted right by 2 bits. CSR `mtinst` or `htinst` may also be written
with information about the faulting instruction or other reason for the
access, as explained in <<tinst-vals>>.|
|22.5.2|When an instruction fetch or a misaligned memory access straddles a page
boundary, two different address translations are involved. When a
guest-page fault occurs in such a circumstance, the faulting virtual
address written to `mtval`/`stval` is the same as would be required for
a regular page fault. Thus, the faulting virtual address may be a
page-boundary address that is higher than the instruction's original
virtual address, if the byte at that page boundary is among the accessed
bytes.|
|22.5.2|When a guest-page fault is not due to an implicit memory access for
VS-stage address translation, a nonzero guest physical address written
to `mtval2`/`htval` shall correspond to the exact virtual address
written to `mtval`/`stval`.|
|22.5.3|The behavior of the SFENCE.VMA instruction is affected by the current
virtualization mode V. When V=0, the virtual-address argument is an
HS-level virtual address, and the ASID argument is an HS-level ASID. The
instruction orders stores only to HS-level address-translation
structures with subsequent HS-level address translations.|
|22.5.3|When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
address within the current virtual machine, and the ASID argument is a
VS-level ASID within the current virtual machine. The current virtual
machine is identified by the VMID field of CSR `hgatp`, and the
effective ASID can be considered to be the combination of this VMID with
the VS-level ASID. The SFENCE.VMA instruction orders stores only to the
VS-level address-translation structures with subsequent VS-stage address
translations for the same virtual machine, i.e., only when `hgatp`.VMID
is the same as when the SFENCE.VMA executed.|
|22.5.3|Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
memory-management fences to complement SFENCE.VMA. These instructions
are described in <<hfence.vma>>.|
|22.5.3|<<pmp-vmem>> discusses the intersection between
physical memory protection (PMP) and page-based address translation. It
is noted there that, when PMP settings are modified in a manner that
affects either the physical memory that holds page tables or the
physical memory to which page tables point, M-mode software must
synchronize the PMP settings with the virtual memory system. For
HS-level address translation, this is accomplished by executing in
M-mode an SFENCE.VMA instruction with _rs1_=`x0` and _rs2_=`x0`, after
the PMP CSRs are written. Synchronization with G-stage and VS-stage data
structures is also needed. Executing an HFENCE.GVMA instruction with
_rs1_=`x0` and _rs2_=`x0` suffices to flush all G-stage or VS-stage
address-translation cache entries that have cached PMP settings
corresponding to the final translated supervisor physical address. An
HFENCE.VVMA instruction is not required.|
|22.5.3|Similarly, if the setting of the PBMTE bit in `menvcfg` is changed, an
HFENCE.GVMA instruction with _rs1_=`x0` and _rs2_=`x0` suffices to synchronize
with respect to the altered interpretation of G-stage and VS-stage PTEs' PBMT
fields.|
|22.5.3|By contrast, if the PBMTE bit in `henvcfg` is changed, executing an
HFENCE.VVMA with _rs1_=`x0` and _rs2_=`x0` suffices to synchronize with
respect to the altered interpretation of VS-stage PTEs' PBMT fields for the
currently active VMID.|
|22.6.1|The hypervisor extension augments the trap cause encoding.
<<hcauses>> lists the possible M-mode and HS-mode
trap cause codes when the hypervisor extension is implemented. Codes are
added for VS-level interrupts (interrupts 2, 6, 10), for
supervisor-level guest external interrupts (interrupt 12), for
virtual-instruction exceptions (exception 22), and for guest-page faults
(exceptions 20, 21, 23). Furthermore, environment calls from VS-mode are
assigned cause 10, whereas those from HS-mode or S-mode use cause 9 as
usual.|
|22.6.1|HS-mode and VS-mode ECALLs use different cause values so they can be
delegated separately.|
|22.6.1|When V=1, a virtual-instruction exception (code 22) is normally raised
instead of an illegal-instruction exception if the attempted instruction
is _HS-qualified_ but is prevented from executing when V=1 either due to
insufficient privilege or because the instruction is expressly disabled
by a supervisor or hypervisor CSR such as `scounteren` or `hcounteren`.
An instruction is _HS-qualified_ if it would be valid to execute in
HS-mode (for some values of the instruction's register operands),
assuming fields TSR and TVM of CSR `mstatus` are both zero.|
|22.6.1|A special rule applies for CSR instructions that access 32-bit high-half
CSRs such as `cycleh` and `htimedeltah`. When V=1 and
XLEN=32, an invalid attempt to access a high-half CSR
raises a virtual-instruction
exception instead of an illegal-instruction exception if the same CSR
instruction for the corresponding _low-half_ CSR (e.g.`cycle` or
`htimedelta`) is HS-qualified.|
|22.6.1|When XLEN>32, an attempt to access a high-half CSR
always raises an illegal-instruction exception.|
|22.6.1|Specifically, a virtual-instruction exception is raised for the
following cases:

* in VS-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in `hcounteren` is 0 and the same bit in `mcounteren`
is 1;
* in VS-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in `hcounteren` is 0 and the same bit in
`mcounteren` is 1;
* in VU-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in either `hcounteren` or `scounteren` is 0 and the
same bit in `mcounteren` is 1;
* in VU-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in either `hcounteren` or `scounteren` is 0
and the same bit in `mcounteren` is 1;
* in VS-mode or VU-mode, attempts to execute a hypervisor instruction
(HLV, HLVX, HSV, or HFENCE);
* in VS-mode or VU-mode, attempts to access an implemented non-high-half
hypervisor CSR or VS CSR when the same access (read/write) would be
allowed in HS-mode, assuming `mstatus`.TVM=0;
* in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented
high-half hypervisor CSR or high-half VS CSR when the same access
(read/write) to the CSR"s low-half partner would be allowed in HS-mode,
assuming `mstatus`.TVM=0;
* in VU-mode, attempts to execute WFI when `mstatus`.TW=0, or to execute
a supervisor instruction (SRET or SFENCE);
* in VU-mode, attempts to access an implemented non-high-half supervisor
CSR when the same access (read/write) would be allowed in HS-mode,
assuming `mstatus`.TVM=0;
* in VU-mode, if XLEN=32, attempts to access an implemented high-half
supervisor CSR when the same access to the CSR's low-half partner would
be allowed in HS-mode, assuming `mstatus`.TVM=0;
* in VS-mode, attempts to execute WFI when `hstatus`.VTW=1 and
`mstatus`.TW=0, unless the instruction completes within an
implementation-specific, bounded time;
* in VS-mode, attempts to execute SRET when `hstatus`.VTSR=1; and
* in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA
instruction or to access `satp`, when `hstatus`.VTVM=1.
|
|22.6.1|On a virtual-instruction trap, `mtval` or `stval` is written the same as
for an illegal-instruction trap.|
|22.6.1|Fields FS and VS in registers `sstatus` and `vsstatus` deviate from the usual
_HS-qualified_ rule.
If an instruction is prevented from executing because FS or VS is zero in
either `sstatus` or `vsstatus`, the exception raised is always an
illegal-instruction exception, never a virtual-instruction exception.|
|22.6.1|If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of <<HSyncExcPrio>>
indicates which exception is taken and reported in `mcause` or `scause`.|
|22.6.2|When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless
delegated by `medeleg` or `mideleg`, in which case it goes to HS-mode.
When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless
delegated by `medeleg` or `mideleg`, in which case it goes to HS-mode,
unless further delegated by `hedeleg` or `hideleg`, in which case it
goes to VS-mode.|

|22.6.2|When a trap is taken into M-mode, virtualization mode V gets set to 0,
and fields MPV and MPP in `mstatus` (or `mstatush`) are set according to
<<h-mpp>>. A trap into M-mode also writes fields GVA,
MPIE, and MIE in `mstatus`/`mstatush` and writes CSRs `mepc`, `mcause`,
`mtval`, `mtval2`, and `mtinst`.|
|22.6.2|When a trap is taken into HS-mode, virtualization mode V is set to 0,
and `hstatus`.SPV and `sstatus`.SPP are set according to
<<h-spp>>. If V was 1 before the trap, field SPVP in
`hstatus` is set the same as `sstatus`.SPP; otherwise, SPVP is left
unchanged. A trap into HS-mode also writes field GVA in `hstatus`,
fields SPIE and SIE in `sstatus`, and CSRs `sepc`, `scause`, `stval`,
`htval`, and `htinst`.|
|22.6.2|When a trap is taken into VS-mode, `vsstatus`.SPP is set according to
<<h-vspp>>. Register `hstatus` and the HS-level
`sstatus` are not modified, and the virtualization mode V remains 1. A
trap into VS-mode also writes fields SPIE and SIE in `vsstatus` and
writes CSRs `vsepc`, `vscause`, and `vstval`.|
|22.6.3|On any trap into M-mode or HS-mode, one of these values is written
automatically into the appropriate trap instruction CSR, `mtinst` or
`htinst`:

* zero;
* a transformation of the trapping instruction;
* a custom value (allowed only if the trapping instruction is
non-standard); or
* a special pseudoinstruction.|

|22.6.3|Except when a pseudoinstruction value is required (described later), the
value written to `mtinst` or `htinst` may always be zero, indicating
that the hardware is providing no information in the register for this
particular trap.|
|22.6.3|On an interrupt, the value written to the trap instruction register is
always zero. On a synchronous exception, if a nonzero value is written,
one of the following shall be true about the value:

* Bit 0 is `1`, and replacing bit 1 with `1` makes the value into a
valid encoding of a standard instruction.
+
In this case, the instruction that trapped is the same kind as indicated
by the register value, and the register value is the transformation of
the trapping instruction, as defined later. For example, if bits 1:0 are
binary `11` and the register value is the encoding of a standard LW
(load word) instruction, then the trapping instruction is LW, and the
register value is the transformation of the trapping LW instruction.
* Bit 0 is `1`, and replacing bit 1 with `1` makes the value into an
instruction encoding that is explicitly designated for a custom
instruction (_not_ an unused reserved encoding).
+
This is a _custom value_. The instruction that trapped is a non-standard
instruction. The interpretation of a custom value is not otherwise
specified by this standard.
* The value is one of the special pseudoinstructions defined later, all
of which have bits 1:0 equal to `00`.|
|22.6.3|<<tinst-values>> shows the values that may be
automatically written to the trap instruction register for each standard
exception cause. For exceptions that prevent the fetching of an
instruction, only zero or a pseudoinstruction value may be written. A
custom value may be automatically written only if the instruction that
traps is non-standard. A future standard or extension may permit other
values to be written, chosen from the set of allowed values established
earlier.|
|22.6.3|For a standard load instruction that is not a compressed instruction and
is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the
transformed instruction has the format shown in
<<transformedloadinst>>.|
|22.6.3|For a standard store instruction that is not a compressed instruction
and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed
instruction has the format shown in
<<transformedstoreinst>>.|
|22.6.3|For a standard atomic instruction (load-reserved, store-conditional, or AMO instruction), the transformed instruction has the format shown in <<transformedatomicinst>>.|
|22.6.3|For a standard virtual-machine load/store instruction (HLV, HLVX, or HSV), the transformed instruction has the format shown in <<transformedvmaccessinst>>.|
|22.6.3|For a standard compressed instruction (16-bit size), the transformed
instruction is found as follows:

. Expand the compressed instruction to its 32-bit equivalent.
. Transform the 32-bit equivalent instruction.
. Replace bit 1 with a `0`.
|
|22.6.3|For guest-page faults, the trap instruction register is written with a
special pseudoinstruction value if: (a) the fault is caused by an
implicit memory access for VS-stage address translation, and (b) a
nonzero value (the faulting guest physical address) is written to
`mtval2` or `htval`. If both conditions are met, the value written to
`mtinst` or `htinst` must be taken from
<<pseudoinsts>>; zero is not allowed.|
|22.6.3|A _write_ pseudoinstruction (`0x00002020` or `0x00003020`) is used for
the case that the machine is attempting automatically to update bits A
and/or D in VS-level page tables. All other implicit memory accesses for
VS-stage address translation will be reads. If a machine never
automatically updates bits A or D in VS-level page tables (leaving this
to software), the _write_ case will never arise. The fact that such a
page table update must actually be atomic, not just a simple write, is
ignored for the pseudoinstruction.|
|22.6.4|The MRET instruction is used to return from a trap taken into M-mode.
MRET first determines what the new privilege mode will be according to
the values of MPP and MPV in `mstatus` or `mstatush`, as encoded in
<<h-mpp>>. MRET then in `mstatus`/`mstatush` sets
MPV=0, MPP=0, MIE=MPIE, and MPIE=1. Lastly, MRET sets the privilege mode
as previously determined, and sets `pc`=`mepc`.|
|22.6.4|The SRET instruction is used to return from a trap taken into HS-mode or
VS-mode. Its behavior depends on the current virtualization mode.|
|22.6.4|When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
what the new privilege mode will be according to the values in
`hstatus`.SPV and `sstatus`.SPP, as encoded in
<<h-spp>>. SRET then sets `hstatus`.SPV=0, and in
`sstatus` sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the
privilege mode as previously determined, and sets `pc`=`sepc`.|
|22.6.4|When executed in VS-mode (i.e., V=1), SRET sets the privilege mode
according to <<h-vspp>>, in `vsstatus` sets SPP=0,
SIE=SPIE, and SPIE=1, and lastly sets `pc`=`vsepc`.|
|22.6.4|If the Ssdbltrp extension is implemented, when `SRET` is executed in HS-mode,
if the new privilege mode is VU, the `SRET` instruction sets `vsstatus.SDT`
to 0. When executed in VS-mode, `vsstatus.SDT` is set to 0.|



|===



==== H

==== ZicsrH

==== ExceptionsH

==== InterruptsH

==== EndianH

==== RV32VM_H

==== RV64VM_H

==== SsstrictH



== List of Non-deterministic behaviors

* Mask and tail agnostic vector operations
* Traps on misaligned accesses
* TODO
* need more discussion about whether this is a meaningful and usable idea

== To Do

I think we might want to rethink some of our privileged testing structure and switch to having Sm, S, and U testplans/coverpoints/tests instead of lumping most of that into ZicsrM/S/U. I will also be more apparent what is being tested where that way.

=== Current Status

At present, coverpoints and tests are being developed in the https://github.com/openhwgroup/cvw-arch-verif/[cvw-arch-verif] repository and being tested on the https://github.com/openhwgroup/cvw[CORE-V Wally] processor.  The goal is to be able to certify RVA23S64 as well as spec-compliant machine mode.

This test plan exists in the form of spreadsheets, and is being converted to ASCII Doc.

As of July 2025, all unprivileged and privileged RVA23S64 features have tests hitting 100% of the coverpoints, with the following exceptions:

* The Vector tests found some bugs in Sail, which are being fixed
* Interrupt tests coverpoints complete, tests partially complete
* PMP tests in progress
* Virtual memory: Sv39 and Sv48 100% coverage, Sv48 debugging one coverpoint
* Hypervisor not started
* Other minor new extensions not started

[appendix]
== Examples

This appendix gives examples of coverpoints and tests consistent with the test plan.  These examples are not the only way to satisfy the testplan.

=== Unprivileged example: `add`

Coverage is in I_coverage.svh:

[[f-add-covergroup]]
.`add` Covergroup
----
covergroup I_add_cg with function sample(ins_t ins);
    option.per_instance = 0;
    cp_asm_count : coverpoint ins.ins_str == "add"  iff (ins.trap == 0 )  {
        //Number of times instruction is executed
        bins count[]  = {1};
    }
    cp_rs1 : coverpoint ins.get_gpr_reg(ins.current.rs1)  iff (ins.trap == 0 )  {
        //RS1 register assignment
    }
    cp_rs2 : coverpoint ins.get_gpr_reg(ins.current.rs2)  iff (ins.trap == 0 )  {
        //RS2 register assignment
    }
    cp_rd : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.trap == 0 )  {
        //RD register assignment
    }
    cp_rs1_edges : coverpoint unsigned'(ins.current.rs1_val)  iff (ins.trap == 0 )  {
        `ifdef XLEN32
            bins zero  =    {0};
            bins one  =     {32'b00000000000000000000000000000001};
            bins two  =     {32'b00000000000000000000000000000010};
            bins min  =     {32'b10000000000000000000000000000000};
            bins minp1  =   {32'b10000000000000000000000000000001};
            bins max  =     {32'b01111111111111111111111111111111};
            bins maxm1  =   {32'b01111111111111111111111111111110};
            bins ones  =    {32'b11111111111111111111111111111111};
            bins onesm1  =  {32'b11111111111111111111111111111110};
            bins walkeodd = {32'b10101010101010101010101010101010};
            bins walkeven = {32'b01010101010101010101010101010101};
            wildcard bins random = {32'b01???????????????????????????010};
        `else
            bins zero  = {0};
            bins one      = {64'b0000000000000000000000000000000000000000000000000000000000000001};
            bins two      = {64'b0000000000000000000000000000000000000000000000000000000000000010};
            bins min      = {64'b1000000000000000000000000000000000000000000000000000000000000000};
            bins minp1    = {64'b1000000000000000000000000000000000000000000000000000000000000001};
            bins Wmax     = {64'b0000000000000000000000000000000011111111111111111111111111111111};
            bins Wmaxm1   = {64'b0000000000000000000000000000000011111111111111111111111111111110};
            bins Wmaxp1   = {64'b0000000000000000000000000000000100000000000000000000000000000000};
            bins Wmaxp2   = {64'b0000000000000000000000000000000100000000000000000000000000000001};
            bins max      = {64'b0111111111111111111111111111111111111111111111111111111111111111};
            bins maxm1    = {64'b0111111111111111111111111111111111111111111111111111111111111110};
            bins ones     = {64'b1111111111111111111111111111111111111111111111111111111111111111};
            bins onesm1   = {64'b1111111111111111111111111111111111111111111111111111111111111110};
            bins walkeodd = {64'b1010101010101010101010101010101010101010101010101010101010101010};
            bins walkeven = {64'b0101010101010101010101010101010101010101010101010101010101010101};
            wildcard bins random = {64'b01???????????????????????????????????????????????????????????010};
        `endif
    }
    cp_rs2_edges : coverpoint unsigned'(ins.current.rs2_val)  iff (ins.trap == 0 )  {
        `ifdef XLEN32
            bins zero  =    {0};
 ...
        `else
            bins zero  = {0};
            ...
        `endif
    }
    cr_rs1_rs2_edges : cross cp_rs1_edges,cp_rs2_edges  iff (ins.trap == 0 )  {
        //Cross coverage of RS1 edges and RS2 edges
    }
    cmp_rs1_rs2 : coverpoint ins.get_gpr_reg(ins.current.rs1)  iff (ins.current.rs1 == ins.current.rs2 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cmp_rd_rs1 : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.current.rd == ins.current.rs1 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cmp_rd_rs2 : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.current.rd == ins.current.rs2 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cmp_rd_rs1_rs2 : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.current.rd == ins.current.rs1 & ins.current.rd == ins.current.rs2 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cp_gpr_hazard_rw : coverpoint check_gpr_hazards(ins.hart, ins.issue)  iff (ins.trap == 0 )  {
        //GPR Hazard
        bins hazards[]  = {NO_HAZARD, RAW_HAZARD, WAW_HAZARD, WAR_HAZARD};
    }
endgroup
----

Corresponding RV32 tests are in tests/rv32/I/I-add.S.  Observe how the directed tests align with the coverpoints and bins.  Register numbers and values are randomized unless they are swept by the coverpoint. The RVTEST_SIGUPD macro compares the result against an expected signature produced by a reference model. When register 0 is used, it is loaded with a random value, but hardwired to 0, so the reference model will show that it behaves as 0.

[[f-add-tests]]
.`add` Tests
----
# Testcase cp_rs1 (Test source rs1 = x0)
li x0, 0xb4e96718 # initialize rs1
li x24, 0xeaa512b3 # initialize rs2
add x25, x0, x24 # perform operation
RVTEST_SIGUPD(x3, x25)

# Testcase cp_rs1 (Test source rs1 = x1)
li x1, 0x81c4ef2a # initialize rs1
li x6, 0x917cfa69 # initialize rs2
add x7, x1, x6 # perform operation
RVTEST_SIGUPD(x3, x7)

...

# Testcase cp_rs1 (Test source rs1 = x31)
mv x21, x31 # switch signature pointer register to avoid conflict with test
li x31, 0x1508dd4e # initialize rs1
li x14, 0x830d07b0 # initialize rs2
add x11, x31, x14 # perform operation
RVTEST_SIGUPD(x21, x11)


# Testcase cp_rd (Test destination rd = x0)
li x19, 0x1d01c852 # initialize rs1
li x9, 0x1bfbf146 # initialize rs2
add x0, x19, x9 # perform operation
RVTEST_SIGUPD(x20, x0)

# Testcase cp_rd (Test destination rd = x1)
li x26, 0x1e3aafcf # initialize rs1
li x19, 0x986da37b # initialize rs2
add x1, x26, x19 # perform operation
RVTEST_SIGUPD(x20, x1)

...

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x0)
li x15, 0x00000000 # initialize rs1
li x5, 0x00000000 # initialize rs2
add x11, x15, x5 # perform operation
RVTEST_SIGUPD(x10, x11)

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x1)
li x1, 0x00000000 # initialize rs1
li x31, 0x00000001 # initialize rs2
add x20, x1, x31 # perform operation
RVTEST_SIGUPD(x10, x20)

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x2)
li x27, 0x00000000 # initialize rs1
li x3, 0x00000002 # initialize rs2
add x11, x27, x3 # perform operation
RVTEST_SIGUPD(x10, x11)

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x80000000)
li x8, 0x00000000 # initialize rs1
li x5, 0x80000000 # initialize rs2
add x16, x8, x5 # perform operation
RVTEST_SIGUPD(x10, x16)
----

=== Test case example: cr_rs1_rs2_edges bin with rs1 = 0x0, rs2 = 0x80000000

```
# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x80000000)
li x8, 0x00000000 # initialize rs1 in randomly selected register
li x5, 0x80000000 # initialize rs2 in randomly selected register
add x16, x8, x5 # perform operation, write randomly selected destination register
# load expected value of 0x800000000 into x20 from table pointed to by x10. Check x20 against x16 and report mismmatch
RVTEST_SIGUPD(x10, x16, x20)
```

RVTEST_SIGUPD macro:
```
if (RVTEST_SELFCHECK) # check result against signature
    LREG x20, 0(x10)
    beq x16, x20, 1f
    ecall
    1f:
else # generate signature
    SREG x16, 0(x10)
    addi x10, x10, WORDSIZE
    nop
```
