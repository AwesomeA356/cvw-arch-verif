    cp_csr_vtype_vlmul_intgt2 : coverpoint get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul")  iff (ins.trap == 0 )  {
        // Value of VTYPE.vlmul (vector register grouping), only the integer values
        bins four  = {3'b010};
        bins eight = {3'b011};
    }

    cp_csr_vtype_vta : coverpoint get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vta")  iff (ins.trap == 0)  {
        // Value of VTYPE.vta (vector tail agnostic)
        bins undisturbed = {0};
        bins agnostic    = {1};
    }

    cp_csr_vl_corners_lmul1 : coverpoint vl_check(ins.hart, ins.issue)  iff (ins.trap == 0 & get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul") == 3'b000)  {
        // Corners values of VL (vector length) for LMUL = 1
        ignore_bins vl_zero   = {vl_zero};
        ignore_bins vl_one   = {vl_one};
        ignore_bins vl_legal = {vl_legal};
        ignore_bins vl_other = {vl_other};
        // If ELEN == VLEN and LMUL == 1 and SEW == ELEN, vlmax = 1 and the following bins cannot be hit
        `ifdef ELEN_EQ_VLEN
            `ifdef SEW_EFFEW_EQ_ELEN
                ignore_bins vl_vlmaxm1 = {vl_vlmaxm1};
                ignore_bins vl_vlmaxd2p1 = {vl_vlmaxd2p1};
            `else
                `ifdef SEW_EFFEW_EQ_ELEN_DIV_2
                    ignore_bins vl_vlmaxd2p1 = {vl_vlmaxd2p1};
                `endif
            `endif
        `endif
        }

    cp_csr_vl_corners_lmul2 : coverpoint vl_check(ins.hart, ins.issue)  iff (ins.trap == 0 & get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul") == 3'b001)  {
        // Corners values of VL (vector length)
        ignore_bins vl_zero   = {vl_zero};
        ignore_bins vl_one   = {vl_one};
        ignore_bins vl_legal = {vl_legal};
        ignore_bins vl_other = {vl_other};
        // If ELEN == VLEN and LMUL == 2, vlmax = 2 and the following bins cannot be hit
        `ifdef ELEN_EQ_VLEN
            `ifdef SEW_EFFEW_EQ_ELEN
                ignore_bins vl_vlmaxd2p1 = {vl_vlmaxd2p1};
            `endif
        `endif
        }

    cp_csr_vl_corners_lmulgt2 : coverpoint vl_check(ins.hart, ins.issue)  iff (ins.trap == 0 & get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul") >= 2)  {
        // Corners values of VL (vector length)
        ignore_bins vl_zero   = {vl_zero};
        ignore_bins vl_one   = {vl_one};
        ignore_bins vl_legal = {vl_legal};
        ignore_bins vl_other = {vl_other};
        }

    cp_csr_vl_lmul1 : cross cp_csr_vtype_vta,cp_csr_vl_corners_lmul1  iff (ins.trap == 0 & get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul") == 3'b000)  {
        //Cross coverage LMUL = 1, vl corners (vlmax, vlmax-1, vlmax/2+1), and VTYPE.vta
    }

    cp_csr_vl_lmul2 : cross cp_csr_vtype_vta,cp_csr_vl_corners_lmul2  iff (ins.trap == 0 & get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul") == 3'b001)  {
        //Cross coverage LMUL = 2, vl corners (vlmax, vlmax-1, vlmax/2+1), and VTYPE.vta
    }

    cp_csr_vl_lmulgt2 : cross cp_csr_vtype_vlmul_intgt2,cp_csr_vtype_vta,cp_csr_vl_corners_lmulgt2  iff (ins.trap == 0 & get_csr_val(ins.hart, ins.issue, `SAMPLE_BEFORE, "vtype", "vlmul") >= 2)  {
        //Cross coverage LMUL > 2, vl corners (vlmax, vlmax-1, vlmax/2+1), and VTYPE.vta
    }
