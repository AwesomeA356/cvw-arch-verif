    cp_vs1_vs2_corners : coverpoint unsigned'({ins.current.vs2_val,ins.current.vs2_val})  iff (ins.trap == 0 & ins.current.sew == SEW)  {
        // Corners values of each element of vs1
        // one element = (SEW){1'b?}
        // # of elements = `VLEN/SEW
        // {vs2, vs1} = {(M)*element, corner_vs2, (`VLEN/SEW-M-1)*element, (N)*element, corner_vs1, (`VLEN/SEW-N-1)*element}
        bins zero  =    {(SEW){1'b0}};
        bins one  =     {(SEW-1){1'b0}, {1'b1}};
        bins two  =     {(SEW-2){1'b0}, {2'b10}};
        bins min  =     {{1'b1}, (SEW-1){1'b0}};
        bins minp1  =   {{1'b1}, (SEW-2){1'b0}, {1'b1}};
        bins max  =     {{1'b0}, (SEW-1){1'b1}};
        bins maxm1  =   {{1'b0}, (SEW-2){1'b1}, {1'b0}};
        bins ones  =    {(SEW){1'b1}};
        bins onesm1  =  {(SEW-1){1'b1}, {1'b0}};
        bins walkeodd = {(SEW/2){2'b10}};
        bins walkeven = {(SEW/2){2'b01}};
        bins random   = {(SEW/8){4'b1101}, (SEW/8){4'b0110}};

        // OR for every value of i (tedious af, will need for loop)
        vecElemCrossCornersBin(`VLEN, SEW, zero, zero) //how to call function in here
    }

// cornerVs1/Vs2 are name of corners
vs_corners = {"zero": "{(SEW){1'b0}}", ...}
def vecElemCrossCornersBin(vlen, sew, cornerVs2, cornerVs1):
    bin = ""
    for i in range(vlen/sew):
        bin = bin + "{(i*SEW){1'b?}, " + vs_corners[cornerVs2] + ", ((`VLEN/SEW-i-1)*SEW){1'b?}, "
              + "(i*SEW){1'b?}, " + vs_corners[cornerVs1] + ", ((`VLEN/SEW-i-1)*SEW){1'b?}}"
        if i != (vlen/sew-1):
            bin = bin + " | "
    f.write(f"        bins {cornerVs2}_{cornerVs1} = {bin};\n")

// verilog functino to check if one bin happened
function int cross_vs2vs1_elem(int vlen, int sew, vs1, vs2);
  logic [vlen-1:0] vs2_val = ins.current.vs2_val;
  logic [vlen-1:0] vs1_val = ins.current.vs1_val;
  int hit = [][]; // need to be fixed
  logic [sew-1:0] corners = [{(SEW){1'b0}}, {(SEW-1){1'b0}, {1'b1}},...];
  define bin // also need to be fixed
  for (int corner_vs1=0; corner_vs1 < length(corners); corner_vs1++) begin
    for (int corner_vs1=0; corner_vs1 < length(corners); corner_vs1++) begin
      for (int i=0; i < (vlen/sew); i++) begin
        if ({vs2_val[i*SEW-:SEW], vs1_val[i*SEW-:SEW]} === {corners[corner_vs2],corners[corner_vs2]})
          hit[corner_vs1][corner_vs1] = 1;
      end
    end
  end
  return hit;
endfunction